<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®¶ç³»åœ–ä½œæˆ V1.00</title>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* --- åŸºæœ¬ãƒ‡ã‚¶ã‚¤ãƒ³ --- */
        :root {
            /* Default Theme (Standard) Variables */
            --bg-color: #f0f2f5;
            --bg-pattern: none;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Yu Gothic", sans-serif;
            --text-color: #333;
            --line-color: #999;

            --card-bg: #ffffff;
            --card-border: 1px solid rgba(0, 0, 0, 0.05);
            --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --card-radius: 4px;

            --male-color: #ffffff;
            --male-border: 4px solid #007aff;
            --female-color: #ffffff;
            --female-border: 4px solid #ff2d55;

            --btn-bg: #007bff;
            --btn-text: #fff;
        }

        /* --- THEME DEFINITIONS --- */
        .theme-standard {
            --bg-color: #f5f5f7;
            --line-color: #c7c7cc;
        }

        .theme-chic {
            --bg-color: #ffffff;
            --font-family: "Didot", "Bodoni MT", "Yu Mincho", serif;
            --text-color: #000;
            --line-color: #000;
            --card-bg: #fff;
            --card-border: 2px solid #000;
            --card-shadow: none;
            --card-radius: 0;
            --male-color: #fff;
            --male-border: 4px solid #000;
            --female-color: #fff;
            --female-border: 1px solid #000;
        }

        .theme-miyabi {
            --bg-color: #fcfaf2;
            --bg-pattern: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjZmNmYWYyIi8+CjxwYXRoIGQ9Ik0wIDBMNCA0Wk00IDBMMCA0WiIgc3Ryb2tlPSIjZThlNGQ5IiBzdHJva2Utd2lkdGg9IjAuNSIvPjwvc3ZnPg==');
            --font-family: "Hina Mincho", "Yu Mincho", serif;
            --text-color: #3e2e28;
            --line-color: #5d4c46;
            --card-bg: #fffcf0;
            --card-border: 1px solid #8e7f77;
            --card-shadow: 2px 2px 0 rgba(94, 76, 70, 0.2);
            --card-radius: 2px;
            --male-color: #e8ecef;
            --male-border: 4px solid #2e4b71;
            --female-color: #f7e6e9;
            --female-border: 4px solid #b5495b;
        }

        .theme-dynasty {
            --bg-color: #8a1c1c;
            --font-family: "Kaiti SC", "STKaiti", "Yu Mincho", serif;
            --text-color: #333;
            --line-color: #d4af37;
            --card-bg: #fffdf5;
            --card-border: 2px solid #d4af37;
            --card-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            --card-radius: 8px;
            --male-color: #fff;
            --male-border: 4px solid #b8860b;
            --female-color: #fff;
            --female-border: 4px solid #d4af37;
        }

        .theme-vintage {
            --bg-color: #e3d5c5;
            --font-family: "Courier New", monospace, serif;
            --text-color: #4a3b2a;
            --line-color: #5c4a35;
            --card-bg: #f2e6d5;
            --card-border: 1px dashed #5c4a35;
            --card-shadow: 1px 1px 3px rgba(60, 45, 30, 0.3);
            --card-radius: 2px;
            --male-color: #e6dac8;
            --male-border: 4px double #5c4a35;
            --female-color: #e6dac8;
            --female-border: 1px solid #5c4a35;
        }

        .theme-pop {
            --bg-color: #fff0f5;
            --bg-pattern: radial-gradient(#ffe4e1 15%, transparent 16%) 0 0 / 20px 20px;
            --font-family: "M PLUS Rounded 1c", "Varela Round", sans-serif;
            --text-color: #555;
            --line-color: #ffa07a;
            --card-bg: #ffffff;
            --card-border: 3px solid #ffb6c1;
            --card-shadow: 4px 4px 0 #ff69b4;
            --card-radius: 15px;
            --male-color: #e0ffff;
            --male-border: 0;
            --female-color: #ffe4e1;
            --female-border: 0;
        }

        .theme-luxury {
            --bg-color: #0f172a;
            --font-family: "Times New Roman", serif;
            --text-color: #1e293b;
            --line-color: #fbbf24;
            --card-bg: #f8fafc;
            --card-border: 2px solid #fbbf24;
            --card-shadow: 0 0 15px rgba(251, 191, 36, 0.3);
            --card-radius: 2px;
            --male-color: #f1f5f9;
            --male-border: 4px solid #94a3b8;
            --female-color: #fff1f2;
            --female-border: 4px solid #fbbf24;
        }

        .theme-nature {
            --bg-color: #f1f8e9;
            --font-family: "Yu Mincho", serif;
            --text-color: #2e4a33;
            --line-color: #66bb6a;
            --card-bg: #ffffff;
            --card-border: 1px solid #81c784;
            --card-shadow: 0 4px 6px rgba(46, 74, 51, 0.1);
            --card-radius: 8px 0 8px 0;
            --male-color: #e8f5e9;
            --male-border: 4px solid #4caf50;
            --female-color: #f1f8e9;
            --female-border: 4px solid #81c784;
        }

        .theme-blueprint {
            --bg-color: #00509d;
            --bg-pattern: linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            --font-family: "Consolas", monospace;
            --text-color: #e0f2fe;
            --line-color: #ffffff;
            --card-bg: #003f88;
            --card-border: 1px solid #4cc9f0;
            --card-shadow: none;
            --card-radius: 0;
            --male-color: #003f88;
            --male-border: 1px solid #fff;
            --female-color: #003f88;
            --female-border: 1px dashed #fff;
        }

        .theme-dark {
            --bg-color: #1a1a1a;
            --font-family: sans-serif;
            --text-color: #e0e0e0;
            --line-color: #666;
            --card-bg: #2d2d2d;
            --card-border: 1px solid #444;
            --card-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            --card-radius: 4px;
            --male-color: #2d2d2d;
            --male-border: 4px solid #177ddc;
            --female-color: #2d2d2d;
            --female-border: 4px solid #c41d7f;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            background-image: var(--bg-pattern);
            background-size: 20px 20px;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: white;
            padding: 8px 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            gap: 5px;
            border-right: 1px solid #ddd;
            padding-right: 10px;
            margin-right: 5px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        button {
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            border: 1px solid #ccc;
            background: #fff;
            font-size: 12px;
            transition: 0.2s;
            white-space: nowrap;
            height: 30px;
        }

        button:hover {
            background: #f0f0f0;
        }

        button:disabled {
            color: #aaa;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #0056b3;
            color: white;
            border: none;
            font-weight: bold;
        }

        .btn-danger {
            background: #fff5f5;
            color: #d63384;
            border-color: #ffc9c9;
        }

        .btn-action {
            background: #e6f7ff;
            color: #0056b3;
            border-color: #91d5ff;
        }

        .btn-toggle-active {
            background: #0056b3;
            color: white;
            border-color: #0056b3;
        }

        #viewport {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 80px;
            box-sizing: border-box;
        }

        #viewport:active {
            cursor: grabbing;
        }

        #content-layer {
            transform-origin: center top;
            transition: transform 0.1s ease-out;
            background-color: #f0f2f5;
            padding: 50px;
            position: relative;
            min-width: 100%;
            min-height: 100%;
        }

        #tree-container {
            position: relative;
            width: 0;
            height: 0;
        }

        /* --- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç”¨ã‚¯ãƒ©ã‚¹ --- */

        /* å®¶æ—ã‚°ãƒ«ãƒ¼ãƒ— (çµ¶å¯¾é…ç½®) - Flow Layout Container */
        .family-group {
            position: absolute;
            white-space: nowrap;
            /* Prevent wrap */
            font-size: 0;
            /* Kill inline-block gaps */
        }

        .family-group>* {
            font-size: initial;
            /* Restore font size */
            vertical-align: top;
            direction: ltr;
            /* Reset direction for children */
        }

        /* ç¸¦æ›¸ãæ™‚ override removed - assuming L-R flow is acceptable or handled by JS */

        /* ç¸¦æ›¸ãæ™‚: é…å¶è€…ã‚’å·¦ã«é…ç½® (Main(å³) <- Spouse(å·¦)) */
        .vertical-mode .family-group {
            direction: rtl;
            /* Reverse visual flow: Main on Right */
        }

        /* ãƒãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ (ç›¸å¯¾é…ç½®: å¹…150 + pad20 + border2 = 172px) */
        /* ãƒãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ (ç›¸å¯¾é…ç½®: å¹…150pxå›ºå®š) */
        .node-card {
            position: relative;
            display: inline-block;
            /* Flow layout */
            vertical-align: top;
            background: var(--card-bg);
            border: var(--card-border);
            border-radius: var(--card-radius);
            padding: 10px;
            width: 170px;
            /* Fixed Width (Increased from 150) */
            min-width: 170px;
            box-shadow: var(--card-shadow);
            text-align: center;
            cursor: pointer;
            user-select: none;
            transition: 0.1s;
            z-index: 5;
            margin: 0;
            /* No margins, spacing handled by container/symbols */
            height: 145px;
            /* Unified Height for Horizontal cards (match mostly tall cards) */
            min-height: 145px;
            /* Flex inside card is fine for centering text */
            display: inline-flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* overflow: hidden; removed to show collapse button */
            overflow: visible;
            box-sizing: border-box;
        }

        /* --- Theme Specific Card Decorations --- */

        /* Dynasty: Meander Pattern (Raiman) Frame */
        .theme-dynasty .node-card::after {
            content: "";
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border: 2px solid #b8860b;
            pointer-events: none;
            /* Simple CSS pattern for "Raimon" look (dashed/dotted mix or multiple borders) - utilizing border-image would be best but simple SVG border is safer for single file */
            opacity: 0.5;
            background-image: linear-gradient(135deg, #d4af37 25%, transparent 25%), linear-gradient(225deg, #d4af37 25%, transparent 25%), linear-gradient(45deg, #d4af37 25%, transparent 25%), linear-gradient(315deg, #d4af37 25%, transparent 25%);
            background-position: 10px 0, 10px 0, 0 0, 0 0;
            background-size: 10px 10px;
            background-repeat: repeat;
            /* Mask content area to only show border */
            -webkit-mask: linear-gradient(#fff, #fff) content-box, linear-gradient(#fff, #fff);
            mask: linear-gradient(#fff, #fff) content-box, linear-gradient(#fff, #fff);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            padding: 4px;
            /* Thickness of the frame pattern */
            z-index: 0;
        }

        /* Miyabi: Gold dust / Cloud texture */
        .theme-miyabi .node-card::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(circle, #d4af37 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.3;
            pointer-events: none;
            z-index: 0;
        }

        .theme-miyabi .node-card {
            border-top-width: 0 !important;
            /* Hide default top border to use custom decoration */
        }

        .theme-miyabi .node-card.sex-male::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: #2e4b71;
        }

        .theme-miyabi .node-card.sex-female::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: #b5495b;
        }


        /* Vintage: Corner flourishes (CSS triangles for simplicity) */
        .theme-vintage .node-card::before {
            content: "";
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border: 1px solid #5c4a35;
            outline: 1px solid #5c4a35;
            outline-offset: -4px;
            pointer-events: none;
        }

        /* Pop: Polka dot background */
        .theme-pop .node-card {
            background-image: radial-gradient(#ffe4e1 20%, transparent 20%);
            background-size: 10px 10px;
        }

        /* Nature: Leaf icon */
        .theme-nature .node-card::after {
            content: "ğŸŒ¿";
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 14px;
            opacity: 0.7;
        }

        /* Blueprint: Grid */
        .theme-blueprint .node-card {
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 10px 10px;
        }

        /* Luxury: Inner gold border */
        .theme-luxury .node-card::after {
            content: "";
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            border: 1px solid #fbbf24;
            pointer-events: none;
        }

        /* ç¸¦æ›¸ããƒ¢ãƒ¼ãƒ‰ (v27) */
        .vertical-mode .node-card {
            writing-mode: vertical-rl;
            text-orientation: upright;
            width: 140px;
            /* Increased to 140px */
            min-width: 140px;
            height: 240px;
            /* Fixed Height */
            min-height: 240px;
            padding: 15px 10px;
            margin: 0;
            justify-content: flex-start;
            /* Right Align Flow */
            align-items: center;
            /* Vertically Center Items */
            gap: 5px;
            /* Add gap between columns */
        }

        .vertical-mode .name-main {
            margin: 0 8px;
            letter-spacing: 2px;
        }

        .vertical-mode .dates {
            writing-mode: horizontal-tb;
            margin-top: auto;
            /* Push from top */
            margin-bottom: auto;
            /* Push from bottom */
            text-align: center;
            align-self: center;
            /* Flex alignment */
            width: fit-content;
            /* Don't expand */
            font-size: 10px;
        }

        .node-card.selected {
            border: 2px solid #ff9800;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
            z-index: 8;
        }

        .node-card:hover {
            transform: scale(1.05);
            z-index: 10;
            border-color: #888;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .node-card.dragging {
            opacity: 0.5;
            border: 2px dashed #333;
        }

        .node-card.drag-target {
            border: 2px solid #ff9800;
            background-color: #fff3e0;
            transform: scale(1.1);
            z-index: 20;
        }

        .name-main {
            font-size: 16px;
            font-weight: bold;
            margin: 5px 0;
        }

        .order-label {
            font-size: 10px;
            background: #eee;
            padding: 2px 6px;
            border-radius: 10px;
            display: inline-block;
            margin-bottom: 3px;
        }

        .dates {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        .memo-text {
            /* Common Reset/Base */
            font-size: 9px;
            color: #777;
            background: none;
            border: none;
            padding: 0;
            margin: 0;

            /* Absolute Positioning to prevent layout shift */
            position: absolute;
            bottom: 3px;
            left: 5%;
            width: 90%;
            height: 12px;
            line-height: 12px;

            /* Single line truncation */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
        }

        .vertical-mode .memo-text {
            /* Vertical Positioning: Left edge */
            writing-mode: vertical-rl;
            text-orientation: upright;

            bottom: auto;
            /* Reset horizontal prop */
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            /* Center vertical */

            width: 12px;
            height: 90%;
            /* Max height */

            /* Reset horizontal styles */
            white-space: nowrap;
            text-align: left;
            /* Top align in vertical */
        }

        .date-sep {
            font-size: 8px;
            color: #aaa;
            margin: 2px 0;
        }

        .name-main,
        .dates,
        .order-label,
        .memo-text {
            pointer-events: none;
        }

        .sex-male {
            background-color: var(--male-color);
            border-top: var(--male-border);
        }

        .sex-female {
            background-color: var(--female-color);
            border-top: var(--female-border);
        }

        /* å©šå§»è¨˜å· (=) */
        .marriage-symbol {
            display: inline-block;
            /* vertical-align: middle; removed */
            width: 20px;
            font-size: 20px;
            color: #999;
            text-align: center;
            font-weight: bold;
            user-select: none;
            margin: 0 15px;
            /* position: relative; removed */
            /* top: 40px; removed */
        }

        .family-group {
            position: absolute;
            white-space: nowrap;
            font-size: 0;
            display: flex;
            align-items: center;
            /* Center items vertically */
        }

        .family-group>* {
            font-size: initial;
            /* Restore font size for children */
            vertical-align: top;
        }

        /* æ—¥ä»˜è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆç”¨ã‚¯ãƒ©ã‚¹ */
        body.hide-dates .dates,
        body.hide-dates .vertical-dates {
            display: none !important;
        }

        /* ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ (è¦ªç”¨) */
        .mini-parents-row {
            position: absolute;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            width: max-content;
            z-index: 6;
        }

        .mini-card {
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            min-width: 60px;
            text-align: center;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            position: relative;
        }

        .mini-card:hover {
            background: #fafafa;
            border-color: #999;
        }

        .mini-connector {
            position: absolute;
            bottom: -10px;
            left: 50%;
            width: 1px;
            height: 10px;
            background: #ccc;
        }

        .mini-card.sex-male {
            border-top: 3px solid #0056b3;
        }

        .mini-card.sex-female {
            border-top: 3px solid #d63384;
        }

        /* ç·š */
        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        path.connection-line {
            fill: none;
            stroke: #666;
            stroke-width: 1.5px;
        }

        path.type-adopted {
            stroke-dasharray: 4, 4;
        }

        /* è¦ªé¸æŠãƒ¢ãƒ¼ãƒ‰ */
        body.selecting-parent .node-card {
            cursor: crosshair;
            border: 2px dashed #0056b3;
            opacity: 0.7;
        }

        body.selecting-parent .node-card:hover {
            opacity: 1;
            background: #e6f7ff;
            transform: scale(1.1);
        }

        #mode-indicator {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            background: rgba(0, 86, 179, 0.9);
            color: white;
            text-align: center;
            padding: 5px;
            z-index: 2000;
            display: none;
            font-weight: bold;
            font-size: 13px;
        }

        /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            overflow-y: auto;
        }

        #edit-modal {
            position: relative;
            top: 5%;
            margin: 0 auto 50px auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            width: 550px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            text-align: left;
        }

        #edit-modal h3 {
            margin-top: 0;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            color: #333;
        }

        .node-title {
            font-weight: bold;
            margin-bottom: 4px;
            font-size: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 4px;
            color: #000;
        }

        .node-details {
            font-size: 12px;
            line-height: 1.4;
            color: #555;
        }

        .node-inlaws {
            font-size: 11px;
            margin-top: 4px;
            color: #777;
            border-top: 1px dotted #ccc;
            padding-top: 2px;
        }

        .inlaw-link {
            cursor: pointer;
            text-decoration: underline;
            color: #0056b3;
        }

        .inlaw-link:hover {
            color: #f60;
        }

        .form-section {
            border: 1px solid #e0e0e0;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            background: #fafafa;
        }

        .form-row {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .form-group {
            margin-bottom: 12px;
            flex: 1;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            color: #555;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .modal-actions {
            text-align: right;
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .action-select {
            display: flex;
            border-bottom: 1px solid #ccc;
            margin-bottom: 20px;
        }

        .action-select button {
            flex: 1;
            border: none;
            background: none;
            border-bottom: 3px solid transparent;
            border-radius: 0;
            padding: 10px;
            font-weight: bold;
            color: #666;
        }

        .action-select button:hover {
            background: #f9f9f9;
        }

        .active-mode {
            border-bottom-color: #0056b3 !important;
            color: #0056b3 !important;
        }

        #notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            display: none;
            z-index: 3000;
        }

        #drop-confirm-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 3000;
        }

        #drop-confirm-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            text-align: center;
        }

        #drop-confirm-content button {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 10px;
        }

        /* æŠ˜ã‚ŠãŸãŸã¿ãƒœã‚¿ãƒ³ */
        .collapse-btn {
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            z-index: 20;
            color: #0056b3;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: 0.2s;
            visibility: hidden;
        }

        .node-card:hover .collapse-btn,
        .collapse-btn.is-collapsed {
            visibility: visible;
        }

        .collapse-btn:hover {
            background: #e6f7ff;
            transform: translateX(-50%) scale(1.1);
        }

        /* --- ä¸–ä»£ãƒ«ãƒ¼ãƒ©ãƒ¼ --- */
        #generation-ruler {
            position: fixed;
            left: 0;
            top: 80px;
            bottom: 0;
            width: 50px;
            background: rgba(255, 255, 255, 0.7);
            border-right: 1px solid #ccc;
            z-index: 500;
            pointer-events: none;
            overflow: hidden;
        }

        .ruler-label {
            position: absolute;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            color: #555;
            white-space: nowrap;
        }

        /* --- ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆç”¨ (ä¸å…·åˆå¯¾ç­–) --- */
        body.exporting * {
            box-shadow: none !important;
        }

        body.exporting .node-card {
            border: 1px solid #333 !important;
            background: white !important;
            /* æ€§åˆ¥ã‚«ãƒ©ãƒ¼å¾©æ´»: ä¸‹å·¦å³ã¯é»’1pxã ãŒã€ä¸Šã ã‘ã¯4pxã§è‰²ã‚’è¨±å¯ */
            border-top-width: 4px !important;
        }

        body.exporting .node-card.sex-male {
            border-top-color: #0056b3 !important;
        }

        body.exporting .node-card.sex-female {
            border-top-color: #d63384 !important;
        }

        body.exporting .node-card.selected {
            border: 1px solid #333 !important;
            /* é¸æŠçŠ¶æ…‹ã‚‚è§£é™¤ */
            box-shadow: none !important;
        }

        body.exporting .collapse-btn,
        body.exporting .mini-card,
        body.exporting .mini-parents-row,
        /* å©šå§»è¨˜å·è‡ªä½“ã¯æ®‹ã™ãŒã€ãã‚Œã«ä»˜éš¨ã™ã‚‹ä½™è¨ˆãªã‚‚ã®ãŒã‚ã‚Œã°éš ã™ */
        body.exporting button,
        body.exporting .form-group,
        body.exporting #toolbar,
        body.exporting #generation-ruler {
            display: none !important;
        }

        body.exporting .marriage-symbol {
            display: block !important;
        }

        body.exporting .inlaw-link {
            text-decoration: none !important;
            color: #333 !important;
            cursor: default !important;
        }
    </style>
</head>

<body>

    <div id="toolbar">
        <div style="font-weight:bold; margin-right:5px;">å®¶ç³»åœ–ä½œæˆ V1.00</div>
        <div class="toolbar-group">
            <button onclick="undo()" id="btn-undo" disabled>â†¶ å¾©åŸ</button>
            <button onclick="redo()" id="btn-redo" disabled>â†· é‡åš</button>
            <button onclick="renderTree()">ğŸ”„ é‡æ–°ç¹ªè£½</button>
        </div>
        <div class="toolbar-group">
            <input type="file" id="upload-input" accept=".xlsx, .xls" style="display:none" />
            <button onclick="document.getElementById('upload-input').click()">ğŸ“‚ è®€å–</button>
            <button class="btn-primary" onclick="exportToExcel()">ğŸ’¾ å„²å­˜</button>
            <button onclick="exportToImage()">ğŸ“· åœ–ç‰‡</button>
        </div>
        <div class="toolbar-group">
            <div style="font-size:11px; color:#666; margin-right:5px;">çˆ¶æ¯é…ç½®:</div>
            <button id="align-left" onclick="setAlignment('left')">å·¦</button>
            <button id="align-center" onclick="setAlignment('center')" class="btn-toggle-active">ä¸­</button>
            <button id="align-right" onclick="setAlignment('right')">å³</button>
        </div>
        <div class="toolbar-group">
            <div style="font-size:11px; color:#666; margin-right:5px;">ä¸»é¡Œ:</div>
            <select id="theme-selector" onchange="changeTheme(this.value)"
                style="font-size:12px; height: 30px; border-radius: 4px; border: 1px solid #ccc; margin-right: 15px;">
                <option value="standard">æ¨™æº–</option>
                <option value="chic">æ™‚å°š(é»‘ç™½)</option>
                <option value="miyabi">é›…è‡´(æ—¥å¼)</option>
                <option value="dynasty">ç‹æœ(ä¸­å¼)</option>
                <option value="vintage">å¤å…¸</option>
                <option value="pop">æµè¡Œ</option>
                <option value="luxury">é«˜ç´š(æ·±è—)</option>
                <option value="nature">è‡ªç„¶</option>
                <option value="blueprint">è—åœ–</option>
                <option value="dark">æ·±è‰²</option>
            </select>
        </div>
        <div class="toolbar-group">
            <div style="font-size:11px; color:#666; margin-right:5px;">å­—é«”:</div>
            <select id="font-selector" onchange="changeFont(this.value)"
                style="font-size:12px; height: 30px; border-radius: 4px; border: 1px solid #ccc;">
                <option value="mincho">æ˜é«”</option>
                <option value="gothic">é»‘é«”</option>
                <option value="kaisho">æ¥·é«”</option>
            </select>
        </div>
        <div class="toolbar-group">
            <button onclick="exportToImage()">åœ–ç‰‡è¼¸å‡º</button>
            <button onclick="exportTiled('image')" style="font-size:11px">åœ–ç‰‡(åˆ†å‰²)</button>
            <button onclick="exportToPDF()">PDFè¼¸å‡º</button>
            <button onclick="exportTiled('pdf')" style="font-size:11px">PDF(åˆ†å‰²)</button>
            <button onclick="exportToSVG()">SVGè¼¸å‡º</button>
            <label style="margin-left: 10px;">
                <input type="checkbox" id="show-dates" checked onchange="toggleDateVisibility(true)"> é¡¯ç¤ºç”Ÿå’å¹´
            </label>
            <span id="view-status" style="font-size:11px; color:#666;"></span>
        </div>
        <div style="flex-grow:1"></div>
        <div style="font-size:10px; color:#666; margin-right:10px;">å¯æ‹–æ›³ç§»å‹•</div>
        <button onclick="toggleVerticalMode()" style="font-size:11px">|| ç›´æ›¸</button>
        <button onclick="toggleDateVisibility()" id="btn-toggle-dates" style="font-size:11px">ğŸ“… ç”Ÿå’</button>
        <button onclick="renovateIDs()" style="font-size:11px">ğŸ†” æ•´ç†ID</button>
        <button onclick="initSampleData()" style="font-size:11px">âœ¨ åˆå§‹åŒ–</button>
    </div>

    <div id="mode-indicator">è«‹é»æ“Šæ–°çš„çˆ¶æ¯ (å–æ¶ˆ: ESC)</div>

    <div id="viewport">
        <!-- ä¸–ä»£ãƒ«ãƒ¼ãƒ©ãƒ¼ -->
        <div id="generation-ruler"></div>

        <div id="content-layer">
            <div id="tree-container"><svg id="svg-layer"></svg></div>
        </div>
    </div>

    <div id="modal-overlay">
        <div id="edit-modal">
            <h3 id="modal-title">ç·¨è¼¯</h3>
            <div class="action-select" id="mode-buttons">
                <button onclick="setMode('child')" id="btn-mode-child">ï¼‹ å­å¥³</button>
                <button onclick="setMode('spouse')" id="btn-mode-spouse">ï¼‹ é…å¶</button>
                <button onclick="setMode('edit')" id="btn-mode-edit">âœ ç·¨è¼¯</button>
            </div>
            <div id="form-content"></div>
            <div class="modal-actions">
                <div id="modal-left-actions" style="display:flex; gap:10px; flex-wrap:wrap;"></div>
                <div>
                    <button onclick="closeModal()">å–æ¶ˆ</button>
                    <button class="btn-primary" onclick="saveChanges()">æ±ºå®š</button>
                </div>
            </div>
        </div>
    </div>

    <div id="drop-confirm-modal">
        <div id="drop-confirm-content">
            <h3>ç§»å‹•ç¢ºèª</h3>
            <p id="drop-msg"></p>
            <button class="btn-primary" onclick="confirmDrop('child')">è¨­ç‚ºæ­¤äººçš„å­å¥³</button>
            <button class="btn-primary" onclick="confirmDrop('spouse')">è¨­ç‚ºæ­¤äººçš„é…å¶</button>
            <button onclick="cancelDrop()">å–æ¶ˆ</button>
        </div>
    </div>

    <div id="notification"></div>

    <script>
        // --- å®šæ•° & å¤‰æ•° ---
        const ERA_DATA = {
            "qing": {
                label: "æ¸…æœ",
                eras: [
                    { name: "é †æ²»", start: 1644 },
                    { name: "åº·ç†™", start: 1662 },
                    { name: "é›æ­£", start: 1723 },
                    { name: "ä¹¾éš†", start: 1736 },
                    { name: "å˜‰æ…¶", start: 1796 },
                    { name: "é“å…‰", start: 1821 },
                    { name: "å’¸è±", start: 1851 },
                    { name: "åŒæ²»", start: 1862 },
                    { name: "å…‰ç·’", start: 1875 },
                    { name: "å®£çµ±", start: 1909 }
                ]
            },
            "japan": {
                label: "æ—¥æœ¬",
                eras: [
                    { name: "å¤©ä¿", start: 1830 },
                    { name: "å¼˜åŒ–", start: 1844 },
                    { name: "å˜‰æ°¸", start: 1848 },
                    { name: "å®‰æ”¿", start: 1854 },
                    { name: "è¬å»¶", start: 1860 },
                    { name: "æ–‡ä¹…", start: 1861 },
                    { name: "å…ƒæ²»", start: 1864 },
                    { name: "æ…¶æ‡‰", start: 1865 },
                    { name: "æ˜æ²»", start: 1868 },
                    { name: "å¤§æ­£", start: 1912 },
                    { name: "æ˜­å’Œ", start: 1926 },
                    { name: "å¹³æˆ", start: 1989 },
                    { name: "ä»¤å’Œ", start: 2019 }
                ]
            },
            "roc": {
                label: "æ°‘åœ‹",
                eras: [
                    { name: "æ°‘åœ‹", start: 1911 },
                    { name: "æ°‘å‰", start: 1912, is_minus: true }
                ]
            }
        };

        // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®šæ•° (ä¿®æ­£æ¸ˆã¿)
        const CARD_ACTUAL_WIDTH = 170; // CSS width: 170px
        const MARRIAGE_SYMBOL_WIDTH = 20;
        const GAP_SIZE = 15; // gap: 15px
        const SPOUSE_BLOCK_WIDTH = GAP_SIZE + MARRIAGE_SYMBOL_WIDTH + GAP_SIZE + CARD_ACTUAL_WIDTH;
        const SIBLING_GAP = 50; // å…„å¼Ÿé–“
        const GENERATION_HEIGHT = 320; // åºƒã‚ã«ç¢ºä¿ (Card Height 240 + margin 80)
        const CARD_WIDTH = 170; // CSS

        let globalData = [];
        let currentRootId = null;
        let selectedNodeId = null;
        let currentMode = 'edit';
        let panState = { scale: 1, x: 0, y: 0, isDragging: false, startX: 0, startY: 0 };
        let selectedNodeIds = new Set();
        let isSelectingParent = false;
        let moveSourceId = null;
        let dragSourceId = null;
        let pendingDropSourceId = null;
        let pendingDropTargetId = null;
        let historyStack = [];
        let historyIndex = -1;
        let parentAlignment = 'center'; // 'left', 'center', 'right'
        let currentFont = 'mincho';

        // --- Undo/Redo ---
        function saveHistory() {
            if (historyIndex < historyStack.length - 1) historyStack = historyStack.slice(0, historyIndex + 1);
            historyStack.push({
                data: JSON.parse(JSON.stringify(globalData)),
                alignment: parentAlignment,
                font: currentFont
            });
            historyIndex++;
            updateUndoRedoButtons();
        }
        function undo() {
            if (historyIndex > 0) { historyIndex--; applyHistoryState(historyStack[historyIndex]); renderTree(); updateUndoRedoButtons(); showNotification("å·²é‚„åŸ"); }
        }
        function redo() {
            if (historyIndex < historyStack.length - 1) { historyIndex++; applyHistoryState(historyStack[historyIndex]); renderTree(); updateUndoRedoButtons(); showNotification("å·²é‡åš"); }
        }
        function applyHistoryState(state) {
            globalData = JSON.parse(JSON.stringify(state.data));
            parentAlignment = state.alignment || 'center';
            currentFont = state.font || 'mincho';
            updateAlignmentUI();
            applyFont(currentFont);
        }
        function updateUndoRedoButtons() { document.getElementById('btn-undo').disabled = (historyIndex <= 0); document.getElementById('btn-redo').disabled = (historyIndex >= historyStack.length - 1); }
        function initHistory() { historyStack = []; historyIndex = -1; saveHistory(); }

        // --- Zoom & Pan ---
        const viewport = document.getElementById('viewport');
        const contentLayer = document.getElementById('content-layer');
        viewport.addEventListener('mousedown', (e) => {
            if (e.target.closest('button') || e.target.closest('.node-card') || e.target.closest('.mini-card')) return;
            panState.isDragging = true; panState.startX = e.clientX - panState.x; panState.startY = e.clientY - panState.y; viewport.style.cursor = 'grabbing';
        });
        window.addEventListener('mousemove', (e) => { if (!panState.isDragging) return; e.preventDefault(); panState.x = e.clientX - panState.startX; panState.y = e.clientY - panState.startY; updateTransform(); });
        window.addEventListener('mouseup', () => { panState.isDragging = false; viewport.style.cursor = 'grab'; });
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scaleAmount = -e.deltaY * 0.001;
            const factor = (1 + scaleAmount);
            const newScale = panState.scale * factor;

            if (newScale > 0.1 && newScale < 5) {
                // ãƒã‚¦ã‚¹ä½ç½®ã‚’åŸºæº–ã«ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
                const rect = viewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´ã«ã‚ˆã‚‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ç§»å‹•é‡ã‚’è¨ˆç®—
                panState.x = mouseX - (mouseX - panState.x) * factor;
                panState.y = mouseY - (mouseY - panState.y) * factor;
                panState.scale = newScale;

                updateTransform();
            }
        }, { passive: false });
        function updateTransform() {
            contentLayer.style.transform = `translate(${panState.x}px, ${panState.y}px) scale(${panState.scale})`;

            // ä¸–ä»£ãƒ«ãƒ¼ãƒ©ãƒ¼ã®è¿½å¾“
            const ruler = document.getElementById('generation-ruler');
            if (ruler) {
                const labels = ruler.querySelectorAll('.ruler-label');
                labels.forEach(label => {
                    const baseY = parseFloat(label.dataset.basey);
                    // contentLayer padding(50) + layout pos.y + card height offset(65)
                    const screenY = (50 + baseY + 65) * panState.scale + panState.y;
                    label.style.top = `${screenY}px`;
                    label.style.transform = `translateY(-50%) scale(${panState.scale})`;
                });
            }
        }
        function resetView() { panState = { scale: 1, x: 0, y: 0, isDragging: false, startX: 0, startY: 0 }; updateTransform(); }

        // --- UI Alignment Toggle ---
        function setAlignment(align) {
            saveHistory();
            parentAlignment = align;
            updateAlignmentUI();
            renderTree();
            showNotification(`é…ç½®å·²è®Šæ›´ç‚º ${align === 'center' ? 'ä¸­å¤®' : align === 'left' ? 'å·¦å´' : 'å³å´'}`);
        }
        function updateAlignmentUI() {
            ['left', 'center', 'right'].forEach(a => {
                const btn = document.getElementById(`align-${a}`);
                if (a === parentAlignment) btn.classList.add('btn-toggle-active');
                else btn.classList.remove('btn-toggle-active');
            });
        }

        // --- Font Switching ---
        function changeFont(fontType) {
            saveHistory();
            currentFont = fontType;
            applyFont(fontType);
            showNotification(`å­—é«”å·²è®Šæ›´ç‚º ${fontType === 'mincho' ? 'æ˜é«”' : fontType === 'gothic' ? 'é»‘é«”' : 'æ¥·é«”'}`);
        }
        function applyFont(fontType) {
            const selector = document.getElementById('font-selector');
            if (selector) selector.value = fontType;

            let fontStack = '"Yu Mincho", "Hiragino Mincho ProN", serif';
            if (fontType === 'gothic') {
                fontStack = '"Yu Gothic", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif';
            } else if (fontType === 'kaisho') {
                fontStack = '"HG æ­£æ¥·æ›¸ä½“-PRO", "HGPæ­£æ¥·æ›¸ä½“-PRO", "HGSæ­£æ¥·æ›¸ä½“-PRO", "æ¥·æ›¸", "Kozuka Mincho Pro", serif';
            }
            // Override theme font by setting inline style on body
            document.body.style.setProperty('--font-family', fontStack);
        }

        // --- Folding ---
        function toggleCollapse(nodeId) {
            const node = globalData.find(d => d.node_code === nodeId);
            if (!node) return;

            // ... (keeping existing collapse logic)
            // ç¾åœ¨ã®ç”»é¢å†…ä½ç½®ã‚’è¨˜éŒ² (è¿½å¾“ç”¨)
            const el = document.getElementById(`node-${nodeId}`);
            let screenPos = null;
            if (el) {
                const rect = el.getBoundingClientRect();
                screenPos = { x: rect.left, y: rect.top };
            }

            saveHistory();
            node.collapsed = !node.collapsed;
            renderTree();

            // å†æç”»å¾Œã®ä½ç½®èª¿æ•´
            if (screenPos) {
                setTimeout(() => {
                    const newEl = document.getElementById(`node-${nodeId}`);
                    if (newEl) {
                        const newRect = newEl.getBoundingClientRect();
                        const dx = screenPos.x - newRect.left;
                        const dy = screenPos.y - newRect.top;
                        panState.x += dx;
                        panState.y += dy;
                        updateTransform();
                    }
                }, 0);
            }
            showNotification(node.collapsed ? "å·²æ”¶åˆ" : "å·²å±•é–‹");
        }

        let isDateVisible = true;
        function toggleDateVisibility(fromCheckbox) {
            const checkbox = document.getElementById('show-dates');

            if (fromCheckbox) {
                isDateVisible = checkbox ? checkbox.checked : true;
            } else {
                // ãƒœã‚¿ãƒ³ã‹ã‚‰å‘¼ã°ã‚ŒãŸå ´åˆ
                isDateVisible = !isDateVisible;
                if (checkbox) checkbox.checked = isDateVisible;
            }

            const btn = document.getElementById('btn-toggle-dates');
            if (isDateVisible) {
                document.body.classList.remove('hide-dates');
                if (btn) btn.style.opacity = '1';
                // showNotification("ç”Ÿæ²¡å¹´ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ"); // é »ç¹ã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã¨ã‚¦ã‚¶ã„ã®ã§é™¤å»ã‚ã‚‹ã„ã¯æ§ãˆã‚ã«
            } else {
                document.body.classList.add('hide-dates');
                if (btn) btn.style.opacity = '0.5';
                // showNotification("ç”Ÿæ²¡å¹´ã‚’éè¡¨ç¤ºã«ã—ã¾ã—ãŸ");
            }
        }

        function expandAll() {
            saveHistory();
            globalData.forEach(d => d.collapsed = false);
            renderTree();
            showNotification("å…¨éƒ¨å±•é–‹");
        }


        // --- â˜…ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ (Subtree Width) ---
        function calculateLayout(data, rootIdFilter) {
            const nodeMap = {}; const childrenMap = {}; const spousesMap = {};
            data.forEach(d => { nodeMap[d.node_code] = d; if (!childrenMap[d.node_code]) childrenMap[d.node_code] = []; if (!spousesMap[d.node_code]) spousesMap[d.node_code] = []; });
            data.forEach(d => {
                if (d.relations.is_spouse && d.relations.spouse_linked_to) { if (spousesMap[d.relations.spouse_linked_to]) spousesMap[d.relations.spouse_linked_to].push(d); }
                else if (d.relations.father_id) { if (childrenMap[d.relations.father_id]) childrenMap[d.relations.father_id].push(d); }
            });
            const isVertical = document.body.classList.contains('vertical-mode');
            Object.keys(spousesMap).forEach(k => { spousesMap[k].sort((a, b) => (a.relations.marriage_order || 0) - (b.relations.marriage_order || 0)); });
            Object.keys(childrenMap).forEach(k => {
                childrenMap[k].sort((a, b) => (a.relations.birth_order || 0) - (b.relations.birth_order || 0));
                if (isVertical) childrenMap[k].reverse();
            });

            // â˜…ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®šæ•°ã®å‹•çš„è¨­å®š
            // ç¸¦æ›¸ãæ™‚ã¯ã‚«ãƒ¼ãƒ‰å¹…ã¨éš™é–“ã‚’ç‹­ãã™ã‚‹
            const dCardWidth = isVertical ? 140 : CARD_ACTUAL_WIDTH; // 110 -> 140
            const dSiblingGap = isVertical ? 50 : SIBLING_GAP;
            const dSpouseBlockWidth = GAP_SIZE + MARRIAGE_SYMBOL_WIDTH + GAP_SIZE + dCardWidth;

            let roots = [];
            if (rootIdFilter) {
                roots = [nodeMap[rootIdFilter]];
            } else {
                roots = data.filter(d =>
                    !d.relations.is_spouse &&
                    !d.relations.father_id &&
                    !d.node_code.endsWith('_fa') &&
                    !d.node_code.endsWith('_mo')
                );
            }
            const positions = {};

            function measureSubtree(nodeId) {
                if (!nodeMap[nodeId]) return 0;
                const node = nodeMap[nodeId];
                const spouses = spousesMap[nodeId] || []; const children = childrenMap[nodeId] || [];

                // å‹•çš„ãªå¹…ã‚’ä½¿ç”¨
                const myGroupWidth = dCardWidth + (spouses.length * dSpouseBlockWidth);

                let childrenTotalWidth = 0;
                if (children.length > 0 && !node.collapsed) {
                    children.forEach(c => { childrenTotalWidth += measureSubtree(c.node_code); });
                    // å‹•çš„ãªã‚®ãƒ£ãƒƒãƒ—ã‚’ä½¿ç”¨
                    childrenTotalWidth += (children.length - 1) * dSiblingGap;
                }

                const requiredWidth = Math.max(myGroupWidth, childrenTotalWidth);
                positions[nodeId] = { width: requiredWidth, myGroupWidth: myGroupWidth, childrenTotalWidth: childrenTotalWidth };
                return requiredWidth;
            }
            function assignCoords(nodeId, startX, startY) {
                if (!nodeMap[nodeId]) return;
                const node = nodeMap[nodeId];
                const pos = positions[nodeId]; const children = childrenMap[nodeId] || [];
                const centerX = startX + pos.width / 2;

                let myLeftX;
                if (parentAlignment === 'left') {
                    myLeftX = centerX - pos.childrenTotalWidth / 2;
                } else if (parentAlignment === 'right') {
                    myLeftX = (centerX + pos.childrenTotalWidth / 2) - pos.myGroupWidth;
                } else {
                    myLeftX = centerX - pos.myGroupWidth / 2; // center
                }

                if (pos.childrenTotalWidth <= pos.myGroupWidth || node.collapsed) {
                    myLeftX = centerX - pos.myGroupWidth / 2;
                }

                pos.x = myLeftX; pos.y = startY;
                let currentChildX = centerX - pos.childrenTotalWidth / 2;
                if (!node.collapsed) {
                    children.forEach(c => { const cPos = positions[c.node_code]; assignCoords(c.node_code, currentChildX, startY + GENERATION_HEIGHT); currentChildX += cPos.width + dSiblingGap; });
                }
            }
            let globalX = 0;
            roots.forEach(root => { if (!root) return; const w = measureSubtree(root.node_code); assignCoords(root.node_code, globalX, 50); globalX += w + dSiblingGap * 2; });
            return { positions, spousesMap };
        }

        // --- Theme Switching ---
        function changeTheme(themeName) {
            // Remove all existing theme classes
            document.body.className = document.body.className.replace(/theme-\w+/g, "").trim();
            // Add new theme class
            if (themeName !== 'standard') {
                document.body.classList.add(`theme-${themeName}`);
            }

            // Allow theme to dictate font again (reset manual override)
            document.body.style.removeProperty('--font-family');

            saveHistory(); // Save preference if needed, or just let it stay separate

            // Re-render lines to pick up new color
            renderTree();
            showNotification(`ä¸»é¡Œå·²è®Šæ›´ç‚ºã€Œ${themeName}ã€`);
        }

        // --- æç”» ---
        function renderTree() {
            try {
                // ... (existing code)
                const layout = calculateLayout(getDisplayData(), currentRootId);
                const posMap = layout.positions;
                const spousesMap = layout.spousesMap; // Fixed: spousesMap definition
                const container = document.getElementById('tree-container');
                container.innerHTML = '<svg id="svg-layer"></svg>';

                // ... (Ruler generation code same as before) ...
                const ruler = document.getElementById('generation-ruler');
                if (ruler) {
                    ruler.innerHTML = '';
                    const yToGens = {};
                    Object.keys(posMap).forEach(id => {
                        const p = posMap[id];
                        const node = globalData.find(d => d.node_code === id);
                        if (node) {
                            if (!yToGens[p.y]) yToGens[p.y] = new Set();
                            yToGens[p.y].add(node.generation);
                        }
                    });
                    Object.keys(yToGens).sort((a, b) => a - b).forEach(y => {
                        const label = document.createElement('div');
                        label.className = 'ruler-label';
                        const genText = Array.from(yToGens[y]).sort((a, b) => a - b).map(g => g + 'ä¸–').join(' / ');
                        label.innerText = genText;
                        label.dataset.basey = y;
                        ruler.appendChild(label);
                    });
                }

                let maxX = 0, maxY = 0;
                Object.keys(posMap).forEach(id => {
                    // ... (Card placement code same as before) ...
                    const pos = posMap[id];
                    const node = globalData.find(d => d.node_code === id);
                    if (!node) return;

                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'family-group';
                    groupDiv.style.left = pos.x + 'px';
                    groupDiv.style.top = pos.y + 'px';

                    groupDiv.appendChild(createCard(node));
                    const spouses = spousesMap[id] || [];
                    spouses.forEach(sp => {
                        const sym = document.createElement('div'); sym.className = 'marriage-symbol'; sym.innerText = '='; sym.id = `bond-${id}-${sp.node_code}`;
                        groupDiv.appendChild(sym);
                        groupDiv.appendChild(createCard(sp));
                    });
                    container.appendChild(groupDiv);
                    if ((pos.x + pos.myGroupWidth) > maxX) maxX = pos.x + pos.myGroupWidth;
                    if ((pos.y + 120) > maxY) maxY = pos.y + 120;
                });

                const svgW = Math.max(maxX + 100, window.innerWidth); const svgH = Math.max(maxY + 200, window.innerHeight);
                container.style.width = svgW + 'px'; container.style.height = svgH + 'px';
                document.getElementById('svg-layer').setAttribute('width', svgW); document.getElementById('svg-layer').setAttribute('height', svgH);
                updateTransform();
                setTimeout(() => { drawLines(); }, 0);
            } catch (e) {
                console.error("Render Error:", e);
            }
        }

        // ... createCard ...

        function drawLines() {
            try {
                const svg = document.getElementById('svg-layer'); const container = document.getElementById('tree-container');
                const containerRect = container.getBoundingClientRect(); const scale = panState.scale;

                // Get line color from CSS variable
                const computedStyle = getComputedStyle(document.body);
                const pathColor = computedStyle.getPropertyValue('--line-color').trim() || "#999";

                function getCenter(elemId) {
                    // ... (same logic)
                    const el = document.getElementById(elemId); if (!el) return null;
                    const rect = el.getBoundingClientRect();
                    const x = (rect.left + rect.width / 2 - containerRect.left) / scale; const y = (rect.top + rect.height / 2 - containerRect.top) / scale;
                    const bottom = (rect.bottom - containerRect.top) / scale; const top = (rect.top - containerRect.top) / scale;
                    return { x, y, bottom, top };
                }

                // ... (grouping logic) ...
                // 1. å­ä¾›ã‚’ã€Œæ¥ç¶šå…ƒ(è¦ª or å©šå§»ãƒœãƒ³ãƒ‰)ã€ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
                const groups = {};
                globalData.forEach(child => {
                    if (!child.relations.is_spouse && child.relations.father_id) {
                        const fatherNode = globalData.find(d => d.node_code === child.relations.father_id);
                        if (fatherNode && fatherNode.collapsed) return;
                        if (!document.getElementById(`node-${child.node_code}`)) return;
                        let sourceId = `bond-${child.relations.father_id}-${child.relations.mother_id}`;
                        if (!document.getElementById(sourceId)) {
                            sourceId = `node-${child.relations.father_id}`;
                        }
                        if (!groups[sourceId]) groups[sourceId] = [];
                        groups[sourceId].push(child);
                    }
                });

                // ... (drawing logic) ...
                Object.keys(groups).forEach(sourceId => {
                    const children = groups[sourceId];
                    if (children.length === 0) return;
                    const sourcePos = getCenter(sourceId);
                    let startPoint = null;
                    if (sourcePos) startPoint = { x: sourcePos.x, y: sourcePos.bottom };
                    if (!startPoint) return;

                    let firstChildTop = null;
                    const childPoints = [];
                    children.forEach(child => {
                        const childPos = getCenter(`node-${child.node_code}`);
                        if (childPos) {
                            if (firstChildTop === null) firstChildTop = childPos.top;
                            childPoints.push({ child, pos: childPos });
                        }
                    });

                    if (childPoints.length === 0) return;
                    const startX = startPoint.x;
                    const startY = startPoint.y;
                    const endY = firstChildTop;
                    const midY = (startY + endY) / 2;
                    const strokeWidth = 2; // Can also be variable if needed

                    // Draw A (Vertical from Parent)
                    const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    vLine.setAttribute('x1', startX); vLine.setAttribute('y1', startY);
                    vLine.setAttribute('x2', startX); vLine.setAttribute('y2', midY);
                    vLine.setAttribute('stroke', pathColor); vLine.setAttribute('stroke-width', strokeWidth);
                    svg.appendChild(vLine);

                    // Draw B (Lines to Children)
                    childPoints.forEach(pt => {
                        const cx = pt.pos.x;
                        const cy = pt.pos.top;

                        const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        hLine.setAttribute('x1', startX); hLine.setAttribute('y1', midY);
                        hLine.setAttribute('x2', cx); hLine.setAttribute('y2', midY);
                        hLine.setAttribute('stroke', pathColor); hLine.setAttribute('stroke-width', strokeWidth);
                        svg.appendChild(hLine);

                        const vLineChild = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        vLineChild.setAttribute('x1', cx); vLineChild.setAttribute('y1', midY);
                        vLineChild.setAttribute('x2', cx); vLineChild.setAttribute('y2', cy);
                        vLineChild.setAttribute('stroke', pathColor); vLineChild.setAttribute('stroke-width', strokeWidth);
                        svg.appendChild(vLineChild);
                    });
                });

            } catch (e) {
                console.error("Line Draw Error:", e);
            }
        }

        function createCard(data) {
            const div = document.createElement('div');
            div.className = `node-card sex-${data.display.sex}`;
            if (selectedNodeIds.has(data.node_code)) div.classList.add('selected');
            div.id = `node-${data.node_code}`;
            initDragEvents(div, data.node_code);

            // ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ (ç¾©çˆ¶æ¯) - ã‚«ãƒ¼ãƒ‰ä¸Šéƒ¨ã«é…ç½®
            const father = globalData.find(d => d.node_code === data.relations.father_id);
            const mother = globalData.find(d => d.node_code === data.relations.mother_id);
            const showFather = father && data.relations.father_id && data.relations.father_id.endsWith('_fa');
            const showMother = mother && data.relations.mother_id && data.relations.mother_id.endsWith('_mo');

            if (showFather || showMother) {
                const inlawsDiv = document.createElement('div'); inlawsDiv.className = 'node-inlaws';
                if (showFather) {
                    const span = document.createElement('span'); span.className = 'inlaw-link'; span.innerText = father.display.name;
                    span.onclick = (e) => { e.stopPropagation(); openModal(father.node_code); };
                    inlawsDiv.appendChild(document.createTextNode("çˆ¶: ")); inlawsDiv.appendChild(span); inlawsDiv.appendChild(document.createTextNode(" "));
                }
                if (showMother) {
                    const span = document.createElement('span'); span.className = 'inlaw-link'; span.innerText = mother.display.name;
                    span.onclick = (e) => { e.stopPropagation(); openModal(mother.node_code); };
                    inlawsDiv.appendChild(document.createTextNode("æ¯: ")); inlawsDiv.appendChild(span);
                }
                div.appendChild(inlawsDiv);
            }

            let label = "";
            if (!data.relations.is_spouse) {
                const rawOrder = data.relations.birth_order;

                // ç”·å¥³åˆ¥é †ä½ã®è¨ˆç®—
                // åŒã˜çˆ¶(ã¾ãŸã¯æ¯)ã‚’æŒã¡ã€ã‹ã¤é…å¶è€…ã§ãªãã€ã‹ã¤åŒã˜æ€§åˆ¥ã®å…„å¼Ÿã‚’å–å¾—
                const sameSexSiblings = globalData.filter(d =>
                    d.relations.father_id === data.relations.father_id &&
                    !d.relations.is_spouse &&
                    d.display.sex === data.display.sex
                );
                // birth_orderé †ã«ã‚½ãƒ¼ãƒˆ
                sameSexSiblings.sort((a, b) => (a.relations.birth_order || 0) - (b.relations.birth_order || 0));

                // è‡ªåˆ†ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¢ã™ (1-based index)
                const rank = sameSexSiblings.findIndex(d => d.node_code === data.node_code) + 1;

                // rankãŒå–å¾—ã§ããªã‹ã£ãŸå ´åˆ(ã‚ã‚Šãˆãªã„ãŒ)ã¯rawOrderã‚’ä½¿ã†ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                const intOrder = Math.floor(rank > 0 ? rank : rawOrder);

                let suffixNum;
                if (intOrder === 1) suffixNum = "é•·";
                else if (intOrder === 2) suffixNum = "æ¬¡";
                else {
                    // 3ä»¥é™ã¯æ¼¢æ•°å­—å¤‰æ›
                    const kanjiNums = ["ã€‡", "ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹", "å"];
                    if (intOrder <= 10) suffixNum = kanjiNums[intOrder];
                    else if (intOrder < 20) suffixNum = "å" + kanjiNums[intOrder % 10];
                    else suffixNum = intOrder; // 20ä»¥ä¸Šã¯ã‚ãã‚‰ã‚ã¦æ•°å­—(ãƒ¬ã‚¢ã‚±ãƒ¼ã‚¹)
                }

                if (rawOrder % 1 !== 0) suffixNum += "'";
                const gender = (data.display.sex === "male") ? "å­" : "å¥³";
                if (rawOrder) label = `<span class="order-label">${suffixNum}${gender}</span>`;
            } else { const mOrder = data.relations.marriage_order; if (mOrder) label = `<span class="order-label">å¦»${mOrder}</span>`; }

            const mainInfo = document.createElement('div');
            const isVertical = document.body.classList.contains('vertical-mode');

            let dateHtml = '';
            const bYear = data.display.birth_year || '?';
            const dYear = data.display.death_year || '?'; // æ²¡å¹´ä¸æ˜ã‚‚?ã«ã™ã‚‹

            let displayName = data.display.name;
            if (isVertical) {
                // ç¸¦æ›¸ãæ™‚ã¯åŠè§’ã‚«ãƒƒã‚³ã‚’å…¨è§’ã‚«ãƒƒã‚³ã«ç½®æ›ã—ã¦ç¸¦è¡¨ç¤ºã«è¦‹ã›ã‚‹
                displayName = displayName.replace(/\(/g, 'ï¼ˆ').replace(/\)/g, 'ï¼‰');
            }

            if (isVertical) {
                dateHtml = `<div class="dates vertical-dates">
            <div>${bYear}</div>
            <div class="date-sep">â”‚</div>
            <div>${dYear}</div>
        </div>`;
            } else {
                dateHtml = `<div class="dates">${bYear} - ${dYear}</div>`;
            }

            mainInfo.innerHTML = `${label}<div class="name-main">${displayName}</div>${dateHtml}`;

            // v28: ãƒ¡ãƒ¢1è¡¨ç¤º
            if (data.display.memo1) {
                const memoDiv = document.createElement('div');
                memoDiv.className = 'memo-text';
                memoDiv.innerText = data.display.memo1;
                mainInfo.appendChild(memoDiv);
            }

            div.appendChild(mainInfo);

            // æŠ˜ã‚ŠãŸãŸã¿ãƒœã‚¿ãƒ³
            const hasChildren = globalData.some(d => d.relations.father_id === data.node_code && !d.relations.is_spouse);
            if (!data.relations.is_spouse && hasChildren) {
                const btn = document.createElement('div');
                btn.className = 'collapse-btn' + (data.collapsed ? ' is-collapsed' : '');
                btn.innerHTML = data.collapsed ? '+' : 'âˆ’';
                btn.onclick = (e) => { e.stopPropagation(); toggleCollapse(data.node_code); };
                div.appendChild(btn);
            }

            div.onclick = (e) => handleNodeClick(e, data.node_code);
            return div;
        }

        function createMiniCard(data, label) {
            const el = document.createElement('div'); el.className = `mini-card sex-${data.display.sex}`;
            el.innerHTML = `<div>${label}: ${data.display.name}</div><div class="mini-connector"></div>`;
            el.onclick = (e) => { e.stopPropagation(); openModal(data.node_code); };
            return el;
        }

        function drawLines() {
            try {
                const svg = document.getElementById('svg-layer'); const container = document.getElementById('tree-container');
                const containerRect = container.getBoundingClientRect(); const scale = panState.scale;
                function getCenter(elemId) {
                    const el = document.getElementById(elemId); if (!el) return null;
                    const rect = el.getBoundingClientRect();
                    const x = (rect.left + rect.width / 2 - containerRect.left) / scale; const y = (rect.top + rect.height / 2 - containerRect.top) / scale;
                    const bottom = (rect.bottom - containerRect.top) / scale; const top = (rect.top - containerRect.top) / scale;
                    return { x, y, bottom, top };
                }

                // 1. å­ä¾›ã‚’ã€Œæ¥ç¶šå…ƒ(è¦ª or å©šå§»ãƒœãƒ³ãƒ‰)ã€ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
                const groups = {}; // key: sourceId, value: [childNode, ...]

                globalData.forEach(child => {
                    if (!child.relations.is_spouse && child.relations.father_id) {
                        // è¦ªãŒéè¡¨ç¤º(æŠ˜ã‚ŠãŸãŸã¿)ã®å ´åˆã¯ç·šã‚’æç”»ã—ãªã„
                        const fatherNode = globalData.find(d => d.node_code === child.relations.father_id);
                        if (fatherNode && fatherNode.collapsed) return;
                        // è‡ªèº«ãŒéè¡¨ç¤ºã®å ´åˆã‚‚æç”»ã—ãªã„
                        if (!document.getElementById(`node-${child.node_code}`)) return;

                        // æ¥ç¶šå…ƒIDã‚’æ±ºå®š
                        let sourceId = `bond-${child.relations.father_id}-${child.relations.mother_id}`; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å¤«å©¦çµ†
                        // å¤«å©¦çµ†ãŒå­˜åœ¨ã—ãªã„(ç‰‡è¦ªã®ã¿etc)å ´åˆ
                        if (!document.getElementById(sourceId)) {
                            sourceId = `node-${child.relations.father_id}`;
                        }

                        if (!groups[sourceId]) groups[sourceId] = [];
                        groups[sourceId].push(child);
                    }
                });

                // 2. ã‚°ãƒ«ãƒ¼ãƒ—ã”ã¨ã«ä¸€æ‹¬æç”» (midYã‚’çµ±ä¸€ã™ã‚‹ãŸã‚)
                Object.keys(groups).forEach(sourceId => {
                    const children = groups[sourceId];
                    if (children.length === 0) return;

                    // æ¥ç¶šå…ƒã®åº§æ¨™å–å¾—
                    const sourcePos = getCenter(sourceId);
                    let startPoint = null;
                    if (sourcePos) {
                        // çµ†(ï¼)ãªã‚‰bottomã€è¦ªãƒãƒ¼ãƒ‰ãªã‚‰bottom
                        startPoint = { x: sourcePos.x, y: sourcePos.bottom };
                    }

                    if (!startPoint) return;

                    // å…¨å­ä¾›ã®åº§æ¨™ã‚’å–å¾—ã—ã€endY (å­ä¾›ã®ä¸Šç«¯) ã®å¹³å‡ã¾ãŸã¯ä»£è¡¨å€¤ã‚’å–ã‚‹
                    // â€»é€šå¸¸ã¯åŒã˜ä¸–ä»£ã®å­ä¾›ã¯åŒã˜é«˜ã•ã«ã‚ã‚‹ã¯ãšã ãŒã€ã‚ºãƒ¬é˜²æ­¢ã®ãŸã‚çµ±ä¸€ã™ã‚‹
                    let firstChildTop = null;
                    const childPoints = [];

                    children.forEach(child => {
                        const childPos = getCenter(`node-${child.node_code}`);
                        if (childPos) {
                            if (firstChildTop === null) firstChildTop = childPos.top;
                            childPoints.push({ child, pos: childPos });
                        }
                    });

                    if (childPoints.length === 0) return;

                    // å…±é€šã®æ°´å¹³ç·šã®é«˜ã• (midY) ã‚’è¨ˆç®—
                    // startY(è¦ªã®ä¸‹ç«¯) ã¨ firstChildTop(å­ä¾›ã®ä¸Šç«¯) ã®ä¸­é–“
                    const startX = startPoint.x;
                    const startY = startPoint.y;
                    const endY = firstChildTop;

                    let midY = (startY + endY) / 2;
                    if (document.body.classList.contains('vertical-mode')) {
                        // ç¸¦æ›¸ãæ™‚ã¯æ¨ªç·šã‚’ä¸‹ã«å¯„ã›ã‚‹ (70%ä½ç½®)
                        midY = startY + (endY - startY) * 0.7;
                    }

                    // --- æç”»å®Ÿè¡Œ ---

                    // A. è¦ªã‹ã‚‰midYã¾ã§ã®å‚ç›´ç·š
                    // è‰²: è¦ªã®æ€§åˆ¥ã§ã¯ãªãã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé»’ or ç‰¹å®šè‰²
                    // ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«é»’(#333) or ã‚°ãƒ¬ãƒ¼(#ccc)
                    const pathColor = "#999";
                    const strokeWidth = 2;

                    // è¦ª -> ä¸­é–“
                    const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    vLine.setAttribute('x1', startX); vLine.setAttribute('y1', startY);
                    vLine.setAttribute('x2', startX); vLine.setAttribute('y2', midY);
                    vLine.setAttribute('stroke', pathColor); vLine.setAttribute('stroke-width', strokeWidth);
                    svg.appendChild(vLine);

                    // B. å­ä¾›ã”ã¨ã®ç·š (midYã‹ã‚‰å­ä¾›ã¸)
                    childPoints.forEach(pt => {
                        const cx = pt.pos.x;
                        const cy = pt.pos.top;

                        // æ°´å¹³ç·šéƒ¨åˆ†: startX (è¦ªã®ç›´ä¸‹) ã‹ã‚‰ cx (å­ä¾›ã®ç›´ä¸Š) ã¾ã§ @ midY
                        // â€»å®Ÿéš›ã¯1æœ¬ã®é•·ã„æ¨ªç·šã§ã¯ãªãã€è¦ªã®ç›´ä¸‹ã‹ã‚‰å„å­ä¾›ã¸ã®ã€ŒLå­—ã€ã®é›†ã¾ã‚Šã¨ã—ã¦æãã€ã¾ãŸã¯
                        //   ä¸€ç•ªå·¦ã®å­ï½ä¸€ç•ªå³ã®å­ã¾ã§1æœ¬ã®æ¨ªç·šã‚’å¼•ãã€ãã“ã‹ã‚‰å„å­ã¸å‚ã‚‰ã™ã€‚
                        //   ã“ã“ã§ã¯ã€Œè¦ªç›´ä¸‹ã‹ã‚‰å„å­ã¸ã€ã®å€‹åˆ¥ãƒ«ãƒ¼ãƒˆã ã¨é‡ãªã‚‹ãŒå•é¡Œãªã„ã€‚
                        //   è¦‹ãŸç›®ã‚’ãã‚Œã„ã«ã™ã‚‹ãªã‚‰ã€ Min(cx) ï½ Max(cx) ã®æ¨ªç·šã‚’1æœ¬å¼•ãã»ã†ãŒè‰¯ã„ã€‚

                        // æ¨ªç·š (è¦ªã®X ï½ å­ã®X)
                        const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        hLine.setAttribute('x1', startX); hLine.setAttribute('y1', midY);
                        hLine.setAttribute('x2', cx); hLine.setAttribute('y2', midY);
                        hLine.setAttribute('stroke', pathColor); hLine.setAttribute('stroke-width', strokeWidth);
                        svg.appendChild(hLine);

                        // å‚ç›´ç·š (midY ï½ å­ã®ä¸Šç«¯)
                        const vLineChild = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        vLineChild.setAttribute('x1', cx); vLineChild.setAttribute('y1', midY);
                        vLineChild.setAttribute('x2', cx); vLineChild.setAttribute('y2', cy);
                        vLineChild.setAttribute('stroke', pathColor); vLineChild.setAttribute('stroke-width', strokeWidth);
                        svg.appendChild(vLineChild);
                    });
                });
            } catch (e) {
                console.error("Line Draw Error:", e);
            }
        }

        // --- DnD (v10 Style) ---
        function initDragEvents(el, id) {
            el.draggable = true;
            el.addEventListener('dragstart', (e) => {
                e.stopPropagation(); dragSourceId = id; el.classList.add('dragging'); e.dataTransfer.effectAllowed = 'move';
            });
            el.addEventListener('dragend', (e) => { el.classList.remove('dragging'); document.querySelectorAll('.drag-target').forEach(el => el.classList.remove('drag-target')); dragSourceId = null; });
            el.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; if (dragSourceId && dragSourceId !== id) el.classList.add('drag-target'); });
            el.addEventListener('dragleave', (e) => { el.classList.remove('drag-target'); });
            el.addEventListener('drop', (e) => { e.preventDefault(); e.stopPropagation(); el.classList.remove('drag-target'); if (dragSourceId && dragSourceId !== id) handleDrop(dragSourceId, id); });
        }
        function handleDrop(sourceId, targetId) {
            // ç¾åœ¨ã®è¤‡æ•°é¸æŠãƒãƒ¼ãƒ‰ã‚’ç‰¹å®š
            let nodesToMove = Array.from(selectedNodeIds);
            if (!nodesToMove.includes(sourceId)) {
                nodesToMove = [sourceId];
            }

            // å¾ªç’°å‚ç…§ãƒã‚§ãƒƒã‚¯
            for (const id of nodesToMove) {
                if (isDescendant(id, targetId)) {
                    alert(`éŒ¯èª¤: ã€Œ${nodesToMove.length > 1 ? 'æ‰€é¸ç¯€é»ä¸­çš„æŸå€‹' : 'æ­¤ç¯€é»'}ã€ä¸èƒ½ç§»å‹•åˆ°å…¶å¾Œä»£ç¯€é»ä¸‹`);
                    return;
                }
            }

            pendingDropSourceId = sourceId; // èµ·ç‚¹ID
            pendingDropTargetId = targetId;
            pendingMoveIds = nodesToMove; // å®Ÿéš›ã«å‹•ã‹ã™å…¨ID

            const targetNode = globalData.find(d => d.node_code === targetId);
            const msg = nodesToMove.length > 1
                ? `æ˜¯å¦å°‡é¸ä¸­çš„ ${nodesToMove.length} äºº\nç§»å‹•åˆ°ã€Œ${targetNode.display.name}ã€ä¸‹ï¼Ÿ`
                : `æ˜¯å¦å°‡ã€Œ${globalData.find(d => d.node_code === sourceId).display.name}ã€\nç§»å‹•åˆ°ã€Œ${targetNode.display.name}ã€ä¸‹ï¼Ÿ`;

            document.getElementById('drop-msg').innerText = msg;
            document.getElementById('drop-confirm-modal').style.display = 'block';
        }
        function cancelDrop() { document.getElementById('drop-confirm-modal').style.display = 'none'; pendingDropSourceId = null; }
        let pendingMoveIds = [];
        function confirmDrop(action) {
            saveHistory();
            try {
                // IDãŒå¤‰ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€å…ˆã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‚ç…§ã‚’å–å¾—ã—ã¦ãŠã
                const nodes = pendingMoveIds.map(id => globalData.find(d => d.node_code === id)).filter(n => n);

                if (nodes.length === 0) {
                    throw new Error("ç§»å‹•å¯¾è±¡ã®ãƒãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
                }

                nodes.forEach(source => {
                    if (action === 'child') moveNodeToParent(source, pendingDropTargetId);
                    else if (action === 'spouse') makeSpouse(source, pendingDropTargetId);
                });

                // Clear selection after move
                selectedNodeIds.clear();

                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’å³åº§ã«é–‰ã˜ã‚‹
                cancelDrop();

                // é‡ã„å‡¦ç†ã‚’é…å»¶ã•ã›ã¦UIãƒ–ãƒ­ãƒƒã‚¯ã‚’é˜²ã
                setTimeout(() => {
                    try {
                        renderTree();
                        saveHistory();
                        showNotification(`${nodes.length} åã‚’ç§»å‹•ã—ã¾ã—ãŸ`);
                    } catch (e) {
                        console.error(e);
                        alert("æç”»ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
                    }
                }, 10);

            } catch (e) {
                console.error(e);
                alert("ç§»å‹•å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
                cancelDrop();
            }
        }
        function makeSpouse(source, targetId) {
            const target = globalData.find(d => d.node_code === targetId);
            const targetSpouses = globalData.filter(d => d.relations.is_spouse && d.relations.spouse_linked_to === targetId);
            const nextOrder = targetSpouses.length + 1;
            source.generation = target.generation;
            source.relations.is_spouse = true; source.relations.spouse_linked_to = targetId; source.relations.marriage_order = nextOrder; source.relations.father_id = null; source.relations.mother_id = null; source.relations.birth_order = null;
            const newId = `${targetId}=${nextOrder}`;
            if (newId !== source.node_code) { const oldId = source.node_code; source.node_code = newId; cascadeIdChange(oldId, newId); }
        }
        function moveNodeToParent(source, newParentId) {
            const newParent = globalData.find(d => d.node_code === newParentId);
            let newFatherId = null, newMotherId = null;
            if (newParent.relations.is_spouse) { newMotherId = newParent.node_code; newFatherId = newParent.relations.spouse_linked_to; }
            else {
                if (newParent.display.sex === 'male') {
                    newFatherId = newParent.node_code;
                    const spouses = globalData.filter(d => d.relations.is_spouse && d.relations.spouse_linked_to === newParentId).sort((a, b) => (a.relations.marriage_order || 0) - (b.relations.marriage_order || 0));
                    if (spouses.length > 0) newMotherId = spouses[0].node_code;
                } else {
                    const spouses = globalData.filter(d => d.relations.is_spouse && d.relations.spouse_linked_to === newParentId);
                    if (spouses.length > 0) { newMotherId = newParent.node_code; newFatherId = spouses[0].node_code; } else { newMotherId = newParent.node_code; }
                }
            }
            if (!newFatherId && !newMotherId) newFatherId = newParent.node_code;
            if (newFatherId && !newMotherId && newParent.display.sex === 'female' && newParent.node_code !== newFatherId) newMotherId = newParent.node_code;

            // â˜…ä¿®æ­£: çˆ¶ãŒå¤‰ã‚ã‚‰ãªã„å ´åˆã¯é †åºã‚’ç¶­æŒã™ã‚‹
            const isFatherUnchanged = (source.relations.father_id === newFatherId && newFatherId !== null);
            let nextOrder;
            if (isFatherUnchanged) {
                nextOrder = source.relations.birth_order;
            } else {
                const targetChildren = globalData.filter(d => d.relations.father_id === newFatherId && !d.relations.is_spouse);
                nextOrder = targetChildren.length > 0 ? Math.max(...targetChildren.map(c => Math.floor(c.relations.birth_order || 0))) + 1 : 1;
            }

            source.generation = newParent.generation + 1;
            source.relations.father_id = newFatherId; source.relations.mother_id = newMotherId; source.relations.is_spouse = false; source.relations.spouse_linked_to = null; source.relations.birth_order = nextOrder;
            const newId = generateIdByOrder(newFatherId, source.generation, source.display.sex, nextOrder);
            if (newId !== source.node_code) { const oldId = source.node_code; source.node_code = newId; cascadeIdChange(oldId, newId); }
        }

        // è¦ªé¸æŠ(ã‚¯ãƒªãƒƒã‚¯)
        function startSelectParentMode() { moveSourceId = selectedNodeId; closeModal(); isSelectingParent = true; document.body.classList.add('selecting-parent'); document.getElementById('mode-indicator').style.display = 'block'; window.addEventListener('keydown', handleEscKey); }
        function handleEscKey(e) { if (e.key === 'Escape') cancelParentSelect(); }
        function cancelParentSelect() { isSelectingParent = false; moveSourceId = null; document.body.classList.remove('selecting-parent'); document.getElementById('mode-indicator').style.display = 'none'; window.removeEventListener('keydown', handleEscKey); }
        function handleNodeClick(e, nodeId) {
            if (panState.isDragging) return; e.stopPropagation();
            if (isSelectingParent) {
                if (moveSourceId === nodeId || isDescendant(moveSourceId, nodeId)) { alert("ç„¡æ³•ç§»å‹•"); return; }
                const s = globalData.find(d => d.node_code === moveSourceId); const t = globalData.find(d => d.node_code === nodeId);
                if (confirm(`æ˜¯å¦å°‡ã€Œ${s.display.name}ã€\nè¨­ç‚ºã€Œ${t.display.name}ã€çš„å­å¥³ï¼Ÿ`)) { saveHistory(); moveNodeToParent(s, nodeId); saveHistory(); renderTree(); showNotification("å·²ç§»å‹•"); }
                cancelParentSelect();
            } else {
                if (e.shiftKey) {
                    if (selectedNodeIds.has(nodeId)) selectedNodeIds.delete(nodeId);
                    else selectedNodeIds.add(nodeId);
                } else {
                    selectedNodeIds.clear();
                    selectedNodeIds.add(nodeId);
                }
                renderTree();
                // ç·¨é›†ç”¨ã®å˜ä¸€é¸æŠIDã‚‚æ›´æ–°ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ï¼‰
                selectedNodeId = nodeId;
                // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯çš„ãªæ„Ÿè¦šã§1ã¤ã ã‘é¸ã‚“ã å ´åˆã«ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
                if (!e.shiftKey) openModal(nodeId);
            }
        }

        // ç·¨é›†ãƒ»å‰Šé™¤
        function openModal(nodeId) {
            selectedNodeId = nodeId;
            selectedNodeIds.clear();
            selectedNodeIds.add(nodeId);
            renderTree();
            document.getElementById('modal-overlay').style.display = 'block';
            const node = globalData.find(d => d.node_code === nodeId);
            const leftArea = document.getElementById('modal-left-actions');
            const isInlaw = nodeId.endsWith('_fa') || nodeId.endsWith('_mo');

            let leftHtml = `<button class="btn-danger" onclick="deleteNode('${nodeId}')">ğŸ—‘ï¸ åˆªé™¤</button>`;
            if (!node.relations.is_spouse && !isInlaw) {
                leftHtml = `<button class="btn-action" onclick="startSelectParentMode()">ğŸ”„ è®Šæ›´çˆ¶æ¯</button><button onclick="setRootToSelected()">ğŸŒ³ é¡¯ç¤ºå®¶ç³»</button>` + leftHtml;
            }

            if (!isInlaw) {
                leftHtml = `<div style="width:100%; margin-bottom:5px; font-size:11px; color:#666">æ–°å¢çˆ¶æ¯:</div><button onclick="addParent('father')">ï¼‹çˆ¶</button><button onclick="addParent('mother')">ï¼‹æ¯</button><hr style="width:100%; border:0; border-top:1px solid #eee; margin:10px 0;">` + leftHtml;
            }
            leftArea.innerHTML = leftHtml;

            // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã®åˆ¶å¾¡
            ['child', 'spouse'].forEach(m => {
                const btn = document.getElementById(`btn-mode-${m}`);
                if (btn) btn.style.display = isInlaw ? 'none' : 'inline-block';
            });

            setMode('edit');
        }
        function closeModal() {
            document.getElementById('modal-overlay').style.display = 'none';
            // ç·¨é›†çµ‚äº†æ™‚ã«é¸æŠçŠ¶æ…‹ã‚’è§£é™¤
            selectedNodeIds.clear();
            renderTree();
        }
        function setMode(mode) { currentMode = mode;['child', 'spouse', 'edit'].forEach(m => { const btn = document.getElementById(`btn-mode-${m}`); if (m === mode) btn.classList.add('active-mode'); else btn.classList.remove('active-mode'); }); document.getElementById('modal-left-actions').style.visibility = (mode === 'edit') ? 'visible' : 'hidden'; renderForm(); }
        function toggleVerticalMode() {
            document.body.classList.toggle('vertical-mode');
            renderTree(); // ç·šã‚’å¼•ãç›´ã™ãŸã‚ã«å¿…è¦
        }
        function deleteNode(targetId) {
            const id = targetId || selectedNodeId;
            if (!id) return;
            // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’ä¸€æ™‚çš„ã«ç„¡åŠ¹åŒ–ã™ã‚‹å ´åˆã¯ã“ã¡ã‚‰
            if (!confirm(`ç¢ºå®šè¦åˆªé™¤å—ï¼Ÿ`)) return;

            saveHistory();
            globalData = globalData.filter(d => d.node_code !== id);
            globalData.forEach(d => {
                if (d.relations.father_id === id) d.relations.father_id = null;
                if (d.relations.mother_id === id) d.relations.mother_id = null;
                if (d.relations.spouse_linked_to === id) d.relations.spouse_linked_to = null;
            });

            saveHistory();
            closeModal();
            selectedNodeId = null;
            selectedNodeIds.clear();
            renderTree();
            showNotification("å·²åˆªé™¤");
        }

        // --- IDæ•´ç†æ©Ÿèƒ½ ---
        function setRootToSelected() { currentRootId = selectedNodeId; closeModal(); renderTree(); resetView(); showNotification("é¡¯ç¤ºå®¶ç³»"); }
        function resetRoot() { currentRootId = null; renderTree(); showNotification("é¡¯ç¤ºå…¨å“¡"); }

        // è¦ªè¿½åŠ 
        function addParent(type) {
            saveHistory();
            const child = globalData.find(d => d.node_code === selectedNodeId);
            if (type === 'father' && child.relations.father_id) { alert("çˆ¶è¦ªå·²è¨­å®š"); return; }
            if (type === 'mother' && child.relations.mother_id) { alert("æ¯è¦ªå·²è¨­å®š"); return; }
            const suffix = (type === 'father') ? "_fa" : "_mo"; const sex = (type === 'father') ? "male" : "female";
            const newId = child.node_code + suffix;
            const parentNode = {
                node_code: newId,
                generation: child.generation - 1,
                relations: { father_id: null, mother_id: null, relation_type: 'biological', is_spouse: false, spouse_linked_to: null, birth_order: 1 },
                display: {
                    name: (type === 'father' ? "çˆ¶" : "æ¯"),
                    sex: sex,
                    birth_year: null, birth_era_type: "", birth_era_name: "", birth_era_year: "", birth_month: "", birth_day: "",
                    death_year: null, death_era_type: "", death_era_name: "", death_era_year: "", death_month: "", death_day: "",
                    zi: "", hao: "", memo1: ""
                },
                collapsed: false
            };
            globalData.push(parentNode);
            if (type === 'father') child.relations.father_id = newId; else child.relations.mother_id = newId;
            saveHistory(); closeModal(); renderTree(); showNotification("å·²æ–°å¢çˆ¶æ¯");
        }

        // ãƒ•ã‚©ãƒ¼ãƒ ç”Ÿæˆ (v13ãƒ™ãƒ¼ã‚¹) - HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—å¯¾å¿œ
        function escapeHtml(unsafe) {
            if (unsafe === null || unsafe === undefined) return "";
            return String(unsafe)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        function createInput(id, label, value, type = "text") { return `<div class="form-group"><label>${label}</label><input id="input-${id}" type="${type}" value="${escapeHtml(value)}"></div>`; }
        function createTextarea(id, label, value) { return `<div class="form-group"><label>${label}</label><textarea id="input-${id}" style="width:100%; height:80px; resize:vertical; border:1px solid #ccc; border-radius:4px; padding:5px; font-family:inherit;">${escapeHtml(value)}</textarea></div>`; }
        function createSelect(id, label, value, options) { let html = `<div class="form-group"><label>${label}</label><select id="input-${id}">`; options.forEach(o => { const selected = (o.val === value) ? "selected" : ""; html += `<option value="${escapeHtml(o.val)}" ${selected}>${escapeHtml(o.label)}</option>`; }); html += `</select></div>`; return html; }
        function createEraSelector(p, tOv, selName, cY, wY, month, day) {
            let html = `
            <div class="form-section">
                <div class="form-section-title">${p === "birth" ? "ç”Ÿ" : "å’"}å¹´æœˆæ—¥</div>
                <div class="form-row">
                    <div class="form-group" style="flex:1"><label>æ™‚ä»£</label>
                        <select id="input-${p}_era_type" onchange="updateEraNames('${p}')">
                            <option value="">(é¸æ“‡)</option>
                            <option value="qing" ${tOv === 'qing' ? 'selected' : ''}>æ¸…æœ</option>
                            <option value="japan" ${tOv === 'japan' ? 'selected' : ''}>æ—¥æœ¬</option>
                            <option value="roc" ${tOv === 'roc' ? 'selected' : ''}>æ°‘åœ‹</option>
                            <option value="west" ${tOv === 'west' ? 'selected' : ''}>è¥¿æ›†</option>
                        </select>
                    </div>
                    <div class="form-group" style="flex:1"><label>å…ƒå·</label><select id="input-${p}_era_name" onchange="calcWestYear('${p}')"></select></div>
                    <div class="form-group" style="flex:0.5"><label>å¹´</label>
                        <input type="number" id="input-${p}_era_year" value="${cY || ''}" oninput="calcWestYear('${p}')">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group" style="flex:1">
                        <label>è¥¿æ›†</label><input type="number" id="input-${p}_year" value="${wY || ''}" style="background:#f9f9f9" readonly>
                    </div>
                    <div class="form-group" style="flex:0.8">
                        <label>æœˆ</label><input type="number" id="input-${p}_month" value="${month || ''}" min="1" max="12">
                    </div>
                    <div class="form-group" style="flex:0.8">
                        <label>æ—¥</label><input type="number" id="input-${p}_day" value="${day || ''}" min="1" max="31">
                    </div>
                </div>
            </div>`;
            setTimeout(() => updateEraNames(p, tOv, selName), 0);
            return html;
        }
        window.updateEraNames = function (p, tOv = null, selName = null) { const typeEl = document.getElementById(`input-${p}_era_type`); if (!typeEl) return; const type = tOv || typeEl.value; const nameEl = document.getElementById(`input-${p}_era_name`); nameEl.innerHTML = ""; if (!type || type === 'west') { nameEl.disabled = true; return; } nameEl.disabled = false; ERA_DATA[type].eras.forEach(e => { const opt = document.createElement('option'); opt.value = e.name.split(" ")[0]; opt.dataset.start = e.start; opt.dataset.is_minus = e.is_minus || false; opt.innerText = e.name; if (selName && e.name.startsWith(selName)) opt.selected = true; nameEl.appendChild(opt); }); calcWestYear(p); };
        window.calcWestYear = function (p) { const typeEl = document.getElementById(`input-${p}_era_type`); if (!typeEl) return; const type = typeEl.value; const nameEl = document.getElementById(`input-${p}_era_name`); const valYear = parseInt(document.getElementById(`input-${p}_era_year`).value); const out = document.getElementById(`input-${p}_year`); if (type === 'west' || !type || !valYear) return; const opt = nameEl.options[nameEl.selectedIndex]; if (!opt) return; const start = parseInt(opt.dataset.start); const isMinus = (opt.dataset.is_minus === "true"); out.value = isMinus ? (start - valYear) : (start + valYear - 1); };

        function renderForm() {
            const node = globalData.find(d => d.node_code === selectedNodeId); let html = '';
            const idDisplay = `<div style="margin-bottom:15px; padding:8px; background:#f0f0f0; border-radius:4px; font-size:11px; color:#666;"><strong>ID:</strong> ${node.node_code} (ä¸å¯ç·¨è¼¯)</div>`;

            if (currentMode === 'edit') {
                html += idDisplay;
                html += `<div class="form-section"><div class="form-section-title">åŸºæœ¬è³‡æ–™</div><div class="form-row">` + createInput("name", "å§“å", node.display.name) + createSelect("sex", "æ€§åˆ¥", node.display.sex, [{ val: 'male', label: 'ç”·' }, { val: 'female', label: 'å¥³' }]) + `</div>`;
                if (!node.relations.is_spouse) html += `<div class="form-row">${createInput("birth_order", "é †åº", node.relations.birth_order, "number")}</div><small style="color:#666">â€»é‡è¤‡æ™‚æœƒè‡ªå‹•åŠ ä¸Š '(å¼•è™Ÿ)</small>`; else html += `<div class="form-row">${createInput("marriage_order", "å©šå§»é †åº", node.relations.marriage_order, "number")}</div>`;

                html += `<div class="form-row">${createInput("zi", "å­—", node.display.zi)}${createInput("hao", "è™Ÿ", node.display.hao)}</div>`;
                html += `</div>` +
                    createEraSelector("birth", node.display.birth_era_type, node.display.birth_era_name, node.display.birth_era_year, node.display.birth_year, node.display.birth_month, node.display.birth_day) +
                    createEraSelector("death", node.display.death_era_type, node.display.death_era_name, node.display.death_era_year, node.display.death_year, node.display.death_month, node.display.death_day) +
                    `<div class="form-section"><div class="form-section-title">å‚™è¨»</div>` +
                    createTextarea("memo1", "å‚™è¨»1 (é¡¯ç¤ºåœ¨å¡ç‰‡)", node.display.memo1) +
                    createTextarea("memo2", "å‚™è¨»2 (éš±è—)", node.display.memo2) +
                    `</div>`;
            }
            else if (currentMode === 'child') {
                const spouses = globalData.filter(d => d.relations.is_spouse && d.relations.spouse_linked_to === selectedNodeId); const children = globalData.filter(d => d.relations.father_id === selectedNodeId && !d.relations.is_spouse); const nextOrder = children.length > 0 ? Math.max(...children.map(c => Math.floor(c.relations.birth_order || 0))) + 1 : 1;
                html += `<p>æ–°å¢ <strong>${node.display.name}</strong> çš„å­å¥³</p>`; if (spouses.length > 0) { let opts = [{ val: "", label: "ä¸æ˜/æœªæŒ‡å®š" }]; spouses.forEach(s => opts.push({ val: s.node_code, label: s.display.name })); html += createSelect("partner_id", "æ¯è¦ª", "", opts); }
                html += `<div class="form-section"><div class="form-row">${createInput("name", "å§“å", "")}${createSelect("sex", "æ€§åˆ¥", "male", [{ val: 'male', label: 'ç”·' }, { val: 'female', label: 'å¥³' }])}</div><div class="form-row">${createInput("birth_order", "é †åº", nextOrder, "number")}${createSelect("relation_type", "é—œä¿‚", "biological", [{ val: 'biological', label: 'è¦ªç”Ÿ' }, { val: 'adopted', label: 'é¤Šå­' }])}</div></div>` + createEraSelector("birth", "japan", "æ˜æ²»", "", "", "", "") + createEraSelector("death", "", "", "", "", "", "");
            }
            else if (currentMode === 'spouse') { const spouses = globalData.filter(d => d.relations.is_spouse && d.relations.spouse_linked_to === selectedNodeId); const nextOrder = spouses.length + 1; const defaultSex = (node.display.sex === 'male') ? 'female' : 'male'; html += `<p>æ–°å¢ <strong>${node.display.name}</strong> çš„é…å¶</p><div class="form-section"><div class="form-row">${createInput("name", "å§“å", "")}${createSelect("sex", "æ€§åˆ¥", defaultSex, [{ val: 'male', label: 'ç”·' }, { val: 'female', label: 'å¥³' }])}${createInput("marriage_order", "å©šå§»é †åº", nextOrder, "number")}</div></div>` + createEraSelector("birth", "", "", "", "", "", "") + createEraSelector("death", "", "", "", "", "", ""); }
            document.getElementById('form-content').innerHTML = html;
        }
        function saveChanges() {
            saveHistory();
            try {
                const val = (id) => { const el = document.getElementById(`input-${id}`); return el ? el.value : ""; };
                const getDates = (p) => ({
                    y: val(`${p}_year`),
                    type: val(`${p}_era_type`),
                    name: val(`${p}_era_name`),
                    eY: val(`${p}_era_year`),
                    m: val(`${p}_month`),
                    d: val(`${p}_day`)
                });
                const bd = getDates("birth"); const dd = getDates("death");

                if (currentMode === 'edit') {
                    const node = globalData.find(d => d.node_code === selectedNodeId);
                    if (!node) throw new Error("æ‰¾ä¸åˆ°ç·¨è¼¯å°è±¡ç¯€é»");

                    node.display.name = val('name');
                    node.display.sex = val('sex');
                    node.display.zi = val('zi');
                    node.display.hao = val('hao');
                    node.display.memo1 = val('memo1');
                    node.display.memo2 = val('memo2');
                    node.display.birth_year = bd.y;
                    node.display.birth_era_type = bd.type;
                    node.display.birth_era_name = bd.name;
                    node.display.birth_era_year = bd.eY;
                    node.display.birth_month = bd.m;
                    node.display.birth_day = bd.d;
                    node.display.death_year = dd.y;
                    node.display.death_era_type = dd.type;
                    node.display.death_era_name = dd.name;
                    node.display.death_era_year = dd.eY;
                    node.display.death_month = dd.m;
                    node.display.death_day = dd.d;

                    if (!node.relations.is_spouse && !selectedNodeId.endsWith('_fa') && !selectedNodeId.endsWith('_mo')) {
                        const rawOrder = val('birth_order');
                        let newOrder = parseFloat(rawOrder);
                        if (isNaN(newOrder)) newOrder = node.relations.birth_order || 1;

                        const siblings = globalData.filter(d => d.relations.father_id === node.relations.father_id && !d.relations.is_spouse && d.node_code !== node.node_code);
                        const conflict = siblings.find(s => s.relations.birth_order === newOrder);
                        if (conflict) {
                            conflict.relations.birth_order += 0.5;
                            const shiftId = generateIdByOrder(conflict.relations.father_id, conflict.generation, conflict.display.sex, conflict.relations.birth_order);
                            const oldShiftId = conflict.node_code;
                            conflict.node_code = shiftId;
                            cascadeIdChange(oldShiftId, shiftId);
                        }
                        node.relations.birth_order = newOrder;
                        const newId = generateIdByOrder(node.relations.father_id, node.generation, node.display.sex, newOrder);
                        if (newId && newId !== node.node_code) {
                            const oldId = node.node_code; node.node_code = newId; cascadeIdChange(oldId, newId);
                        }
                    } else if (node.relations.is_spouse) {
                        let mOrder = parseInt(val('marriage_order'));
                        if (isNaN(mOrder)) mOrder = node.relations.marriage_order || 1;
                        node.relations.marriage_order = mOrder;
                    }
                } else if (currentMode === 'child') {
                    const parent = globalData.find(d => d.node_code === selectedNodeId);
                    let order = parseFloat(val('birth_order'));
                    if (isNaN(order)) order = 1;
                    const sex = val('sex');
                    const siblings = globalData.filter(d => d.relations.father_id === selectedNodeId && !d.relations.is_spouse);
                    const conflict = siblings.find(s => s.relations.birth_order === order);
                    if (conflict) { conflict.relations.birth_order += 0.5; const shiftId = generateIdByOrder(conflict.relations.father_id, conflict.generation, conflict.display.sex, conflict.relations.birth_order); const oldShiftId = conflict.node_code; conflict.node_code = shiftId; cascadeIdChange(oldShiftId, shiftId); }
                    const newId = generateIdByOrder(selectedNodeId, parent.generation + 1, sex, order);
                    globalData.push({
                        node_code: newId,
                        generation: parent.generation + 1,
                        relations: { father_id: selectedNodeId, mother_id: val('partner_id') || null, relation_type: val('relation_type'), birth_order: order, is_spouse: false },
                        display: {
                            name: val('name'), sex: sex, zi: "", hao: "", memo1: "",
                            birth_year: bd.y, birth_era_type: bd.type, birth_era_name: bd.name, birth_era_year: bd.eY, birth_month: bd.m, birth_day: bd.d,
                            death_year: dd.y, death_era_type: dd.type, death_era_name: dd.name, death_era_year: dd.eY, death_month: dd.m, death_day: dd.d
                        },
                        collapsed: false
                    });
                } else if (currentMode === 'spouse') {
                    const parent = globalData.find(d => d.node_code === selectedNodeId);
                    let order = parseInt(val('marriage_order'));
                    if (isNaN(order)) order = 1;
                    const newId = `${selectedNodeId}=${order}`;
                    globalData.push({
                        node_code: newId,
                        generation: parent.generation,
                        relations: { is_spouse: true, spouse_linked_to: selectedNodeId, marriage_order: order, father_id: null, mother_id: null },
                        display: {
                            name: val('name'), sex: val('sex'), zi: "", hao: "", memo1: "",
                            birth_year: bd.y, birth_era_type: bd.type, birth_era_name: bd.name, birth_era_year: bd.eY, birth_month: bd.m, birth_day: bd.d,
                            death_year: dd.y, death_era_type: dd.type, death_era_name: dd.name, death_era_year: dd.eY, death_month: dd.m, death_day: dd.d
                        },
                        collapsed: false
                    });
                }
                showNotification("å·²ä¿å­˜");
            } catch (e) {
                console.error(e);
                alert("ä¿å­˜æ™‚ç™¼ç”ŸéŒ¯èª¤: " + e.message);
            } finally {
                closeModal();
                renderTree();
            }
        }

        // å…±é€šæ©Ÿèƒ½ (çœç•¥ãªã—)
        function isDescendant(ancestorId, potentialDescendantId) {
            if (ancestorId === potentialDescendantId) return true;
            const node = globalData.find(d => d.node_code === potentialDescendantId); if (!node) return false;
            if (node.relations.father_id === ancestorId || node.relations.mother_id === ancestorId) return true;
            if (node.relations.father_id && isDescendant(ancestorId, node.relations.father_id)) return true;
            if (node.relations.mother_id && isDescendant(ancestorId, node.relations.mother_id)) return true;
            return false;
        }
        function cascadeIdChange(oldId, newId) {
            if (!oldId || !newId || oldId === newId) return;
            globalData.forEach(d => {
                if (d.relations.father_id === oldId) { d.relations.father_id = newId; if (!d.relations.is_spouse) { const newChildId = generateIdByOrder(newId, d.generation, d.display.sex, d.relations.birth_order); if (d.node_code !== newChildId) { const o = d.node_code; d.node_code = newChildId; cascadeIdChange(o, newChildId); } } }
                if (d.relations.mother_id === oldId) d.relations.mother_id = newId;
                if (d.relations.spouse_linked_to === oldId) { d.relations.spouse_linked_to = newId; const newSpouseId = `${newId}=${d.relations.marriage_order}`; if (d.node_code !== newSpouseId) { const o = d.node_code; d.node_code = newSpouseId; cascadeIdChange(o, newSpouseId); } }
            });
        }
        function generateIdByOrder(parentId, generation, sex, order) {
            if (!parentId) return null;
            const match = parentId ? parentId.match(/^([A-Za-z0-9]+)-(\d+)$/) : null; let baseCode = match ? match[1] : parentId;
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; const intOrder = Math.floor(order);
            let charIndex = (intOrder - 1) % 26; let suffix = letters[charIndex];
            if (intOrder > 26) suffix += letters[(intOrder - 1) % 26];
            if (sex === 'female') suffix = suffix.toLowerCase();
            if (order % 1 !== 0) suffix += "_dup";
            return `${baseCode}${suffix}-${generation}`;
        }
        function getDisplayData() {
            if (!currentRootId) {
                // å…¨å“¡è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã§ã‚‚æŠ˜ã‚ŠãŸãŸã¿ã‚’è€ƒæ…®
                const visibleIds = new Set();
                function collect(id) {
                    if (visibleIds.has(id)) return;
                    visibleIds.add(id);
                    const node = globalData.find(d => d.node_code === id);
                    if (node && !node.collapsed) {
                        globalData.filter(d => d.relations.father_id === id).forEach(c => collect(c.node_code));
                    }
                    globalData.filter(d => d.relations.is_spouse && d.relations.spouse_linked_to === id).forEach(s => visibleIds.add(s.node_code));
                }
                // ãƒ«ãƒ¼ãƒˆï¼ˆè¦ªãªã—ï¼‰ã‹ã‚‰é–‹å§‹
                globalData.filter(d => !d.relations.father_id && !d.relations.is_spouse && !d.node_code.endsWith('_fa') && !d.node_code.endsWith('_mo')).forEach(r => collect(r.node_code));
                return globalData.filter(d => visibleIds.has(d.node_code) && !d.node_code.endsWith('_fa') && !d.node_code.endsWith('_mo'));
            }
            const res = new Set(); const st = [currentRootId];
            while (st.length) {
                const id = st.pop(); if (res.has(id)) continue; res.add(id);
                const node = globalData.find(d => d.node_code === id);
                if (node && !node.collapsed) {
                    globalData.filter(d => d.relations.father_id === id || d.relations.mother_id === id).forEach(c => st.push(c.node_code));
                }
                globalData.filter(d => d.relations.is_spouse && d.relations.spouse_linked_to === id).forEach(s => res.add(s.node_code));
            }
            return globalData.filter(d => res.has(d.node_code) && !d.node_code.endsWith('_fa') && !d.node_code.endsWith('_mo'));
        }
        // --- IDæ•´ç†æ©Ÿèƒ½ ---
        function renovateIDs() {
            // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’ä¸€æ™‚çš„ã«ç„¡åŠ¹åŒ–
            // if (!confirm("IDã‚’æŒ¯ã‚Šç›´ã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆç¾åœ¨ã®ãƒ«ãƒ¼ãƒˆã‚’èµ·ç‚¹ã«å…¨ã¦ã®IDãŒå†ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ï¼‰")) return;
            saveHistory();

            // ãƒ«ãƒ¼ãƒˆç‰¹å®š
            let root = null;
            if (currentRootId) root = globalData.find(d => d.node_code === currentRootId);
            if (!root) root = globalData.find(d => !d.relations.father_id && !d.relations.is_spouse && !d.node_code.endsWith('_fa') && !d.node_code.endsWith('_mo'));
            if (!root) { alert("æ‰¾ä¸åˆ°æ ¹ç¯€é»"); return; }

            const idMap = {}; // old -> new
            const queue = [];

            // ãƒ«ãƒ¼ãƒˆè¨­å®š
            const rootOldId = root.node_code;
            const rootNewId = 'A-1';
            idMap[rootOldId] = rootNewId;

            // BFSç”¨ã‚­ãƒ¥ãƒ¼: { oldId, newId, generation }
            queue.push({ oldId: rootOldId, newId: rootNewId, generation: 1 });

            // è¨ªå•æ¸ˆã¿(oldId)
            const visited = new Set();
            visited.add(rootOldId);

            // â˜…è¦ª(çˆ¶æ¯)ã‚‚ä¸€ç·’ã«ãƒªãƒãƒ¼ãƒ ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
            function processAttachedParents(targetOldId, targetNewId) {
                const targetNode = globalData.find(d => d.node_code === targetOldId);
                if (!targetNode) return;

                ['father', 'mother'].forEach(type => {
                    const pid = (type === 'father') ? targetNode.relations.father_id : targetNode.relations.mother_id;
                    if (pid) {
                        // æ—¢ã«IDãƒãƒƒãƒ—ã«ã‚ã‚‹ã‹ã€ã¾ãŸã¯visitedãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
                        if (idMap[pid]) return;

                        // ãã®IDãŒå®Ÿåœ¨ã™ã‚‹ã‹
                        const parentNode = globalData.find(d => d.node_code === pid);
                        if (!parentNode) return;

                        // suffixåˆ¤å®š: é€šå¸¸ã¯ _fa / _mo
                        // æ—¢å­˜IDãŒ _fa / _mo ã§çµ‚ã‚ã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã—ã¦ã‚‚ã‚ˆã„ãŒã€
                        // ã‚·ãƒ³ãƒ—ãƒ«ã« type ã«åˆã‚ã›ã¦ä»˜ä¸ã™ã‚‹ (addParentã®å®Ÿè£…ã«åˆã‚ã›ã‚‹)
                        const suffix = (type === 'father') ? '_fa' : '_mo';
                        const newPid = targetNewId + suffix;

                        idMap[pid] = newPid;
                        visited.add(pid);
                    }
                });
            }

            while (queue.length > 0) {
                const { oldId: pOldId, newId: pNewId, generation: pGen } = queue.shift();

                // 0. è‡ªåˆ†è‡ªèº«ã®è¦ª(ç›´ç³»ã®è¦ªã§ã¯ãªãè¨­å®šã•ã‚ŒãŸ_fa/_moãªã©)ã‚’å‡¦ç†
                processAttachedParents(pOldId, pNewId);

                // 1. é…å¶è€…ã‚’æ¢ã—ã¦ãƒãƒƒãƒ—ã«è¿½åŠ 
                // spouse_linked_to === pOldId
                const spouses = globalData.filter(d => d.relations.is_spouse && d.relations.spouse_linked_to === pOldId);
                // marriage_orderé †ã«
                spouses.sort((a, b) => (a.relations.marriage_order || 0) - (b.relations.marriage_order || 0));

                spouses.forEach(sp => {
                    const spNewId = `${pNewId}=${sp.relations.marriage_order || 1}`;
                    idMap[sp.node_code] = spNewId;
                    visited.add(sp.node_code);

                    // â˜…é…å¶è€…ã®è¦ªï¼ˆç¾©çˆ¶æ¯ï¼‰ã‚‚å‡¦ç†
                    processAttachedParents(sp.node_code, spNewId);
                });

                // 2. å­ä¾›ã‚’æ¢ã—ã¦ãƒãƒƒãƒ—ã«è¿½åŠ 
                // father_id === pOldId
                const children = globalData.filter(d => !d.relations.is_spouse && d.relations.father_id === pOldId);
                // birth_orderé †ã«
                children.sort((a, b) => (a.relations.birth_order || 0) - (b.relations.birth_order || 0));

                children.forEach((child, index) => {
                    // IDç”Ÿæˆ
                    const order = index + 1;
                    const nextGen = pGen + 1;

                    const match = pNewId.match(/^([A-Za-z0-9]+)-(\d+)$/);
                    const baseCode = match ? match[1] : pNewId;

                    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                    let charIndex = (order - 1) % 26;
                    let suffix = letters[charIndex];
                    if (order > 26) suffix += letters[(order - 1) % 26];
                    if (child.display.sex === 'female') suffix = suffix.toLowerCase();

                    const newChildId = `${baseCode}${suffix}-${nextGen}`;

                    idMap[child.node_code] = newChildId;
                    visited.add(child.node_code);

                    queue.push({ oldId: child.node_code, newId: newChildId, generation: nextGen });
                });
            }

            // ä¸€æ‹¬ç½®æ›é©ç”¨
            globalData.forEach(d => {
                const oldId = d.node_code;

                // å‚ç…§ã®æ›´æ–°
                if (d.relations.father_id && idMap[d.relations.father_id]) {
                    d.relations.father_id = idMap[d.relations.father_id];
                }
                if (d.relations.mother_id && idMap[d.relations.mother_id]) {
                    d.relations.mother_id = idMap[d.relations.mother_id];
                }
                if (d.relations.spouse_linked_to && idMap[d.relations.spouse_linked_to]) {
                    d.relations.spouse_linked_to = idMap[d.relations.spouse_linked_to];
                }

                // è‡ªåˆ†è‡ªèº«ã®IDæ›´æ–°
                if (idMap[oldId]) {
                    d.node_code = idMap[oldId];
                    const parts = idMap[oldId].split('-');
                    if (parts.length > 1) {
                        const g = parseInt(parts[parts.length - 1]);
                        if (!isNaN(g)) d.generation = g;
                    }
                }
            });

            // é¸æŠçŠ¶æ…‹ã®ã‚¯ãƒªã‚¢
            selectedNodeId = null;
            selectedNodeIds.clear();

            // ãƒ«ãƒ¼ãƒˆIDã®æ›´æ–°
            if (currentRootId && idMap[currentRootId]) {
                currentRootId = idMap[currentRootId];
            } else if (root) {
                currentRootId = rootNewId;
            }

            renderTree();
            showNotification(`å·²é‡æ–°åˆ†é…ID (å°è±¡: ${Object.keys(idMap).length}ä»¶)`);
        }
        async function exportToImage() {
            showNotification("æ­£åœ¨ç”Ÿæˆåœ–ç‰‡...");
            await performExport('image');
        }

        async function exportToPDF() {
            showNotification("æ­£åœ¨ç”ŸæˆPDF...");
            await performExport('pdf');
        }

        // å…±é€šã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå‡¦ç† (å…¨ä½“ -> åˆ†å‰²)
        async function performExport(format) {
            // çŠ¶æ…‹ä¿å­˜
            const savedSelection = new Set(selectedNodeIds);
            const savedCollapsedState = new Map();
            globalData.forEach(d => savedCollapsedState.set(d.node_code, d.collapsed));
            const savedPanState = JSON.parse(JSON.stringify(panState));

            selectedNodeIds.clear();

            // PanStateãƒªã‚»ãƒƒãƒˆ
            panState = { scale: 1, x: 0, y: 0, isDragging: false, startX: 0, startY: 0 };

            // æç”»å®Ÿè¡Œ
            renderTree();
            document.body.classList.add('exporting');

            // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¨­å®š
            const viewport = document.getElementById("viewport");
            const originalJustify = viewport.style.justifyContent;
            const originalAlign = viewport.style.alignItems;
            viewport.style.justifyContent = "flex-start";
            viewport.style.alignItems = "flex-start";

            // èƒŒæ™¯è‰² & ã‚µã‚¤ã‚ºå›ºå®š
            const contentLayer = document.getElementById("content-layer");
            contentLayer.style.backgroundColor = "#ffffff";
            contentLayer.style.boxShadow = "none";
            contentLayer.style.minWidth = "0";
            contentLayer.style.minHeight = "0";
            contentLayer.style.width = "auto";
            contentLayer.style.height = "auto";

            // æç”»å®‰å®šå¾…ã¡
            await new Promise(r => setTimeout(r, 500));

            // ã‚µã‚¤ã‚ºè¨ˆæ¸¬
            const treeContainer = document.getElementById("tree-container");
            const treesW = treeContainer.offsetWidth;
            const treesH = treeContainer.offsetHeight;
            const finalW = treesW + 100;
            const finalH = treesH + 100;

            contentLayer.style.width = finalW + "px";
            contentLayer.style.height = finalH + "px";

            const CANVAS_LIMIT = 30000;
            const startScale = 1;
            const isTooBigForCanvas = (finalW * startScale > CANVAS_LIMIT || finalH * startScale > CANVAS_LIMIT);

            // Canvasç”Ÿæˆãƒ˜ãƒ«ãƒ‘ãƒ¼
            const tryRender = async (scale) => {
                return await html2canvas(contentLayer, {
                    scale: scale,
                    backgroundColor: "#ffffff",
                    windowWidth: finalW,
                    windowHeight: finalH,
                    width: finalW,
                    height: finalH,
                    scrollX: 0, scrollY: 0, x: 0, y: 0,
                    logging: false,
                    useCORS: true
                });
            };

            // â˜…ä¿®æ­£: ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’PromiseåŒ–ã—ã¦awaitã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
            const downloadCanvas = (canvas, filenameBase) => {
                return new Promise((resolve, reject) => {
                    try {
                        if (format === 'image') {
                            canvas.toBlob((blob) => {
                                if (!blob) { reject("Blob failed"); return; }
                                const url = URL.createObjectURL(blob);
                                const link = document.createElement('a');
                                link.download = `${filenameBase}.png`;
                                link.href = url;
                                link.click();
                                setTimeout(() => { URL.revokeObjectURL(url); resolve(); }, 1000); // å°‘ã—å¾…ã¤
                            }, 'image/png');
                        } else {
                            // PDF
                            const { jsPDF } = window.jspdf;
                            const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: [canvas.width * 0.75, canvas.height * 0.75] });
                            try {
                                pdf.addImage(canvas, 'PNG', 0, 0, canvas.width * 0.75, canvas.height * 0.75);
                            } catch (e) {
                                pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, 0, canvas.width * 0.75, canvas.height * 0.75);
                            }
                            pdf.save(`${filenameBase}.pdf`);
                            setTimeout(resolve, 500);
                        }
                    } catch (e) {
                        console.error("Download Error", e);
                        reject(e);
                    }
                });
            };

            let canvas = null;
            let errorOccurred = false;

            try {
                if (isTooBigForCanvas) {
                    console.warn(`Size too big for single canvas: ${finalW}x${finalH} (x${startScale})`);
                    throw new Error("Size limit exceeded (pre-check)");
                }

                try {
                    canvas = await tryRender(startScale);
                } catch (e) {
                    console.warn(`Export failed at scale ${startScale}`, e);
                    throw e;
                }

                if (canvas) {
                    await downloadCanvas(canvas, 'family_tree'); // awaitè¿½åŠ 
                    showNotification("å·²ä¿å­˜");
                } else {
                    throw new Error("Canvas is null");
                }

            } catch (error) {
                console.error("Full Export Failed:", error);
                errorOccurred = true;
            } finally {
                // å¾©å…ƒ
                viewport.style.justifyContent = originalJustify;
                viewport.style.alignItems = originalAlign;
                contentLayer.style.backgroundColor = "";
                contentLayer.style.boxShadow = "";
                contentLayer.style.minWidth = ""; contentLayer.style.minHeight = "";
                contentLayer.style.width = ""; contentLayer.style.height = "";

                document.body.classList.remove('exporting');
                savedSelection.forEach(id => selectedNodeIds.add(id));

                globalData.forEach(d => {
                    const state = savedCollapsedState.get(d.node_code);
                    if (state !== undefined) d.collapsed = state;
                });

                panState = savedPanState;

                setTimeout(async () => {
                    renderTree();

                    if (errorOccurred) {
                        await new Promise(r => setTimeout(r, 100)); // å°‘ã—å¾…ã£ã¦ã‹ã‚‰Confirm
                        if (confirm("å› å°ºå¯¸é™åˆ¶ç„¡æ³•è¼¸å‡ºå…¨é«”ã€‚\næ˜¯å¦åŸ·è¡Œã€Œåˆ†å‰²è¼¸å‡ºï¼ˆæŒ‰å®¶ç³»å€‹åˆ¥è¼¸å‡ºï¼‰ã€ï¼Ÿ")) {
                            await exportSmartSplit(format, tryRender, downloadCanvas, CANVAS_LIMIT);
                        }
                    }
                }, 100);
            }
        }

        // ã‚¹ãƒãƒ¼ãƒˆåˆ†å‰²å‡ºåŠ› (å†å¸°çš„ãƒ»å¼·åŒ–ç‰ˆ)
        async function exportSmartSplit(format, renderFn, downloadFn, canvasLimit) {
            showNotification("é–‹å§‹åˆ†å‰²è¼¸å‡º...");

            // çŠ¶æ…‹ä¿å­˜
            const savedSelection = new Set(selectedNodeIds);
            const savedCollapsedState = new Map();
            globalData.forEach(d => savedCollapsedState.set(d.node_code, d.collapsed));
            const savedPanState = JSON.parse(JSON.stringify(panState));
            const viewport = document.getElementById("viewport");
            const originalJustify = viewport.style.justifyContent;
            const originalAlign = viewport.style.alignItems;
            const contentLayer = document.getElementById("content-layer");

            selectedNodeIds.clear();

            // PanStateãƒªã‚»ãƒƒãƒˆ
            panState = { scale: 1, x: 0, y: 0, isDragging: false, startX: 0, startY: 0 };

            document.body.classList.add('exporting');
            viewport.style.justifyContent = "flex-start";
            viewport.style.alignItems = "flex-start";

            let exportCount = 0;

            try {
                let rootNode = null;
                if (currentRootId) rootNode = globalData.find(d => d.node_code === currentRootId);
                if (!rootNode) rootNode = globalData.find(d => !d.relations.father_id && !d.relations.is_spouse && !d.node_code.endsWith('_fa') && !d.node_code.endsWith('_mo'));

                if (!rootNode) { alert("æ‰¾ä¸åˆ°æ ¹ç¯€é»"); return; }

                const splitScale = 1;

                const processNode = async (targetNode) => {
                    const children = globalData.filter(d => !d.relations.is_spouse && d.relations.father_id === targetNode.node_code);
                    children.sort((a, b) => (a.relations.birth_order || 0) - (b.relations.birth_order || 0));

                    // å­ä¾›ãŒã„ãªã„å ´åˆï¼ˆæœ«ç«¯ï¼‰ã¯ã€ã“ã®ãƒ«ãƒ¼ãƒ—ã«ã¯å…¥ã‚‰ãªã„ -> å‘¼ã³å‡ºã—å…ƒãŒå‡¦ç†ã™ã¹ãã ãŒã€
                    // processNodeã¯ã€ŒtargetNodeã®å­ä¾›ãŸã¡ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã€é–¢æ•°ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
                    // ãªã®ã§ã€childrenãŒ0ãªã‚‰ä½•ã‚‚ã—ãªã„ã®ã¯æ­£ã—ã„ã€‚
                    // å•é¡Œã¯ã€ŒtargetNodeè‡ªä½“ãŒãƒ‡ã‚«ã™ãã¦processNode(targetNode)ãŒå‘¼ã°ã‚ŒãŸãŒã€å­ä¾›ãŒã„ãªã„ã€ã‚±ãƒ¼ã‚¹ã€‚

                    if (children.length === 0) return;

                    for (let i = 0; i < children.length; i++) {
                        const child = children[i];

                        // è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
                        setBranchVisibility(child.node_code);
                        renderTree();

                        contentLayer.style.backgroundColor = "#ffffff";
                        contentLayer.style.minWidth = "0";
                        contentLayer.style.minHeight = "0";
                        contentLayer.style.width = "auto";
                        contentLayer.style.height = "auto";

                        await new Promise(r => setTimeout(r, 300)); // å®‰å®šå¾…ã¡

                        const treeContainer = document.getElementById("tree-container");
                        const finalW = treeContainer.offsetWidth + 100;
                        const finalH = treeContainer.offsetHeight + 100;

                        contentLayer.style.width = finalW + "px";
                        contentLayer.style.height = finalH + "px";

                        // â˜…ä¿®æ­£: ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
                        const canExport = (finalW * splitScale < canvasLimit && finalH * splitScale < canvasLimit);
                        // â˜…ä¿®æ­£: ã‚‚ã—ã“ã‚Œä»¥ä¸Šãƒ‰ãƒªãƒ«ãƒ€ã‚¦ãƒ³ã§ããªã„ï¼ˆå­ä¾›ãŒã„ãªã„ï¼‰ãªã‚‰ã€ã‚µã‚¤ã‚ºã‚ªãƒ¼ãƒãƒ¼ã§ã‚‚å¼·åˆ¶å‡ºåŠ›ã™ã‚‹ã—ã‹ãªã„
                        const grandChildren = globalData.filter(d => !d.relations.is_spouse && d.relations.father_id === child.node_code);
                        const isLeafBranch = (grandChildren.length === 0);

                        if (canExport || isLeafBranch) {
                            if (!canExport) console.warn("Exporting oversized branch because it is a leaf:", child.display.name);

                            const filename = `FamilyTree_${formatName(child.display.name)}`;
                            showNotification(`${child.display.name} å®¶ã‚’å‡ºåŠ›ä¸­...`);
                            try {
                                const canvas = await html2canvas(contentLayer, {
                                    scale: splitScale,
                                    backgroundColor: "#ffffff",
                                    windowWidth: finalW,
                                    windowHeight: finalH,
                                    width: finalW,
                                    height: finalH,
                                    scrollX: 0, scrollY: 0, x: 0, y: 0,
                                    logging: false,
                                    useCORS: true
                                });
                                await downloadFn(canvas, filename); // awaitè¿½åŠ 
                                exportCount++;
                                await new Promise(r => setTimeout(r, 1500)); // ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰åˆ¶é™å›é¿ã®ãŸã‚ã«ã‚¦ã‚§ã‚¤ãƒˆ
                            } catch (e) {
                                console.error(`Failed to export ${child.display.name}`, e);
                                // å¤±æ•—ã—ãŸã‚‰ãƒ‰ãƒªãƒ«ãƒ€ã‚¦ãƒ³è©¦è¡Œ
                                await processNode(child);
                            }
                        } else {
                            console.log(`${child.display.name} is too big, drilling down...`);
                            await processNode(child);
                        }
                    }
                };

                await processNode(rootNode);
                showNotification(`åˆ†å‰²å‡ºåŠ›å®Œäº†: ${exportCount}ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);

            } catch (e) {
                console.error("Smart Split Error:", e);
                alert("åˆ†å‰²å‡ºåŠ›ã‚¨ãƒ©ãƒ¼: " + e.message);
            } finally {
                // å¾©å…ƒ
                const contentLayer = document.getElementById("content-layer");
                panState = savedPanState;
                selectedNodeIds.clear();
                savedSelection.forEach(id => selectedNodeIds.add(id));
                globalData.forEach(d => {
                    const state = savedCollapsedState.get(d.node_code);
                    if (state !== undefined) d.collapsed = state;
                });

                document.body.classList.remove('exporting');
                viewport.style.justifyContent = originalJustify;
                viewport.style.alignItems = originalAlign;

                contentLayer.style.backgroundColor = "";
                contentLayer.style.boxShadow = "";
                contentLayer.style.minWidth = "";
                contentLayer.style.minHeight = "";
                contentLayer.style.width = "";
                contentLayer.style.height = "";

                setTimeout(() => renderTree(), 100);
            }
        }

        // SVGå‡ºåŠ›
        async function exportToSVG() {
            showNotification("SVGãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆä¸­...");

            // 1. æº–å‚™ï¼šãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°çŠ¶æ…‹ã‚’æ•´ãˆã‚‹ï¼ˆä»–ã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
            const savedSelection = new Set(selectedNodeIds);
            const savedPanState = JSON.parse(JSON.stringify(panState));
            const savedCollapsedState = new Map();
            globalData.forEach(d => savedCollapsedState.set(d.node_code, d.collapsed));

            selectedNodeIds.clear();
            panState = { scale: 1, x: 0, y: 0, isDragging: false, startX: 0, startY: 0 };
            renderTree();

            document.body.classList.add('exporting');
            const viewport = document.getElementById("viewport");
            const originalJustify = viewport.style.justifyContent;
            const originalAlign = viewport.style.alignItems;
            viewport.style.justifyContent = "flex-start";
            viewport.style.alignItems = "flex-start";

            const contentLayer = document.getElementById("content-layer");
            contentLayer.style.backgroundColor = "#ffffff";
            contentLayer.style.boxShadow = "none";
            contentLayer.style.minWidth = "0"; contentLayer.style.minHeight = "0";
            contentLayer.style.width = "auto"; contentLayer.style.height = "auto";

            // å®‰å®šå¾…ã¡
            await new Promise(r => setTimeout(r, 500));

            try {
                const treeContainer = document.getElementById("tree-container");
                const width = treeContainer.offsetWidth + 100; // padding
                const height = treeContainer.offsetHeight + 100;

                // 2. ã‚¹ã‚¿ã‚¤ãƒ«ã‚·ãƒ¼ãƒˆã®æŠ½å‡º
                let cssText = "";
                for (const sheet of document.styleSheets) {
                    try {
                        // åŒä¸€ã‚ªãƒªã‚¸ãƒ³ã®CSSã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
                        if (sheet.cssRules) {
                            for (const rule of sheet.cssRules) {
                                cssText += rule.cssText + "\n";
                            }
                        }
                    } catch (e) {
                        console.warn("Cannot access stylesheet rules: ", e);
                    }
                }
                // ç‰¹å®šã®ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´
                cssText += `
                    #content-layer { transform: none !important; left: 0 !important; top: 0 !important; margin: 50px; }
                    .card { box-shadow: none; border: 1px solid #000; }
                `;

                // 3. ç”»åƒã®Base64åŒ–
                // ã‚¯ãƒ­ãƒ¼ãƒ³ã‚’ä½œæˆã—ã¦æ“ä½œã™ã‚‹
                const clone = contentLayer.cloneNode(true);
                clone.style.width = width + "px";
                clone.style.height = height + "px";

                // SVGå†…ã®imgã‚¿ã‚°ã¯DataURLã§ãªã„ã¨è¡¨ç¤ºã•ã‚Œãªã„ã“ã¨ãŒå¤šã„
                const images = clone.getElementsByTagName("img");
                const originalImages = contentLayer.getElementsByTagName("img");

                for (let i = 0; i < images.length; i++) {
                    const img = images[i];
                    const original = originalImages[i];
                    if (original && original.complete) {
                        // Canvasã‚’ä½¿ã£ã¦Base64åŒ–
                        try {
                            const canvas = document.createElement("canvas");
                            canvas.width = original.naturalWidth;
                            canvas.height = original.naturalHeight;
                            const ctx = canvas.getContext("2d");
                            ctx.drawImage(original, 0, 0);
                            img.src = canvas.toDataURL("image/png");
                        } catch (e) {
                            console.warn("Image conversion failed", e);
                        }
                    }
                }

                // 4. XMLã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
                const serializer = new XMLSerializer();
                const domString = serializer.serializeToString(clone);

                // 5. SVGä½œæˆ (<foreignObject>ä½¿ç”¨)
                const svgString = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">
                        <style>
                            ${cssText}
                        </style>
                        <foreignObject width="100%" height="100%">
                            <div xmlns="http://www.w3.org/1999/xhtml">
                                ${domString}
                            </div>
                        </foreignObject>
                    </svg>
                `;

                // 6. ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.download = "family_tree.svg";
                link.href = url;
                link.click();

                showNotification("SVGã‚’ä¿å­˜ã—ã¾ã—ãŸ");
                setTimeout(() => URL.revokeObjectURL(url), 1000);

            } catch (e) {
                console.error("SVG Export Error:", e);
                alert("SVGå‡ºåŠ›ã‚¨ãƒ©ãƒ¼: " + e.message);
            } finally {
                // å¾©å…ƒ
                viewport.style.justifyContent = originalJustify;
                viewport.style.alignItems = originalAlign;
                contentLayer.style.backgroundColor = "";
                contentLayer.style.boxShadow = "";
                contentLayer.style.minWidth = ""; contentLayer.style.minHeight = "";
                contentLayer.style.width = ""; contentLayer.style.height = "";
                document.body.classList.remove('exporting');
                savedSelection.forEach(id => selectedNodeIds.add(id));
                globalData.forEach(d => {
                    const state = savedCollapsedState.get(d.node_code);
                    if (state !== undefined) d.collapsed = state;
                });
                panState = savedPanState;
                setTimeout(() => renderTree(), 100);
            }
        }

        // ã‚¿ã‚¤ãƒ«åˆ†å‰²å‡ºåŠ› (åº§æ¨™ãƒ™ãƒ¼ã‚¹)
        async function exportTiled(format) {
            showNotification("ã‚¿ã‚¤ãƒ«åˆ†å‰²å‡ºåŠ›ã‚’é–‹å§‹ã—ã¾ã™...");

            // 1. æº–å‚™ (ä»–ã¨åŒã˜)
            const savedSelection = new Set(selectedNodeIds);
            const savedPanState = JSON.parse(JSON.stringify(panState));
            const savedCollapsedState = new Map();
            globalData.forEach(d => savedCollapsedState.set(d.node_code, d.collapsed));

            selectedNodeIds.clear();
            panState = { scale: 1, x: 0, y: 0, isDragging: false, startX: 0, startY: 0 };
            renderTree();

            document.body.classList.add('exporting');
            const viewport = document.getElementById("viewport");
            const originalJustify = viewport.style.justifyContent;
            const originalAlign = viewport.style.alignItems;
            viewport.style.justifyContent = "flex-start";
            viewport.style.alignItems = "flex-start";

            const contentLayer = document.getElementById("content-layer");
            contentLayer.style.backgroundColor = "#ffffff";
            contentLayer.style.boxShadow = "none";
            contentLayer.style.minWidth = "0"; contentLayer.style.minHeight = "0";
            contentLayer.style.width = "auto"; contentLayer.style.height = "auto";

            await new Promise(r => setTimeout(r, 500));

            try {
                const treeContainer = document.getElementById("tree-container");
                const finalW = treeContainer.offsetWidth + 100;
                const finalH = treeContainer.offsetHeight + 100;
                contentLayer.style.width = finalW + "px";
                contentLayer.style.height = finalH + "px";

                // è¨­å®š: ã‚¿ã‚¤ãƒ«å¹… (A3æ¨ªæƒ³å®šã§ç´„3000pxç¨‹åº¦ã€ã‚ã‚‹ã„ã¯è¦‹ã‚„ã™ã•é‡è¦–ã§å¤§ãã)
                // 3500pxç¨‹åº¦ã«ã™ã‚‹ï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—å«ã‚€ï¼‰
                const TILE_WIDTH = 3500;
                const OVERLAP = 50;

                let pdf = null;
                if (format === 'pdf') {
                    const { jsPDF } = window.jspdf;
                    // åˆæœŸåŒ– (orientationã¯ãƒšãƒ¼ã‚¸ã”ã¨ã«è¿½åŠ æ™‚ã«æŒ‡å®šã™ã‚‹æ‰‹ã‚‚ã‚ã‚‹ãŒã€ã“ã“ã§ã¯æ¨ªé•·çµ±ä¸€)
                    pdf = new jsPDF({ orientation: 'landscape', unit: 'pt' });
                }

                let pageCount = 0;
                // å·¦ã‹ã‚‰é †ã«ã‚­ãƒ£ãƒ—ãƒãƒ£
                for (let x = 0; x < finalW; x += (TILE_WIDTH - OVERLAP)) {
                    pageCount++;
                    const isLast = (x + TILE_WIDTH) >= finalW;
                    const currentW = Math.min(TILE_WIDTH, finalW - x);

                    // html2canvasã§åº§æ¨™æŒ‡å®šã‚­ãƒ£ãƒ—ãƒãƒ£
                    // windowWidth/windowHeightã‚’finalã‚µã‚¤ã‚ºã«æŒ‡å®šã—ã€
                    // x, width ã§åˆ‡ã‚ŠæŠœã
                    showNotification(`æ­£åœ¨ç”Ÿæˆé é¢ ${pageCount}...`);

                    const canvas = await html2canvas(contentLayer, {
                        scale: 1,
                        backgroundColor: "#ffffff",
                        windowWidth: finalW,
                        windowHeight: finalH,
                        width: currentW,
                        height: finalH,
                        x: x,
                        y: 0,
                        scrollX: 0, scrollY: 0, // ã“ã‚ŒãŒé‡è¦
                        logging: false,
                        useCORS: true
                    });

                    if (format === 'image') {
                        // ç”»åƒã¨ã—ã¦å³ä¿å­˜
                        const filename = `family_tree_part${pageCount}.png`;
                        canvas.toBlob((blob) => {
                            if (!blob) return;
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.download = filename;
                            link.href = url;
                            link.click();
                            setTimeout(() => URL.revokeObjectURL(url), 1000);
                        }, 'image/png');
                        await new Promise(r => setTimeout(r, 1000)); // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¾…æ©Ÿ
                    } else {
                        // PDFã«è¿½åŠ 
                        const imgData = canvas.toDataURL('image/png');
                        // PDFãƒšãƒ¼ã‚¸ã‚µã‚¤ã‚ºã‚’ç”»åƒã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹ (ptæ›ç®—: 1px = 0.75pt)
                        const pdfW = currentW * 0.75;
                        const pdfH = finalH * 0.75;

                        if (pageCount > 1) pdf.addPage([pdfW, pdfH], 'landscape');
                        else pdf.deletePage(1), pdf.addPage([pdfW, pdfH], 'landscape'); // åˆæœŸãƒšãƒ¼ã‚¸å‰Šé™¤ã—ã¦è¿½åŠ  (ã‚µã‚¤ã‚ºåˆã‚ã›)

                        pdf.addImage(imgData, 'PNG', 0, 0, pdfW, pdfH);
                    }
                }

                if (format === 'pdf' && pdf) {
                    showNotification("æ­£åœ¨ä¿å­˜PDF...");
                    pdf.save("family_tree_tiled.pdf");
                }

                showNotification("å·²å®Œæˆ");

            } catch (e) {
                console.error("Tiled Export Error:", e);
                alert("åˆ†å‰²è¼¸å‡ºéŒ¯èª¤: " + e.message);
            } finally {
                // å¾©å…ƒ
                viewport.style.justifyContent = originalJustify;
                viewport.style.alignItems = originalAlign;
                contentLayer.style.backgroundColor = "";
                contentLayer.style.boxShadow = "";
                contentLayer.style.minWidth = ""; contentLayer.style.minHeight = "";
                contentLayer.style.width = ""; contentLayer.style.height = "";
                document.body.classList.remove('exporting');
                savedSelection.forEach(id => selectedNodeIds.add(id));
                globalData.forEach(d => {
                    const state = savedCollapsedState.get(d.node_code);
                    if (state !== undefined) d.collapsed = state;
                });
                panState = savedPanState;
                setTimeout(() => renderTree(), 100);
            }
        }
        function setBranchVisibility(targetNodeId) {
            const target = globalData.find(d => d.node_code === targetNodeId);
            if (!target) return;

            // 1. è¦ªã‚’å–å¾—
            const fatherId = target.relations.father_id;
            if (!fatherId) return; // ãƒ«ãƒ¼ãƒˆã®å ´åˆã¯ä½•ã‚‚ã—ãªã„ï¼ˆã‚ã‚‹ã„ã¯å…¨å“¡è¡¨ç¤ºï¼Ÿï¼‰

            // 2. å…„å¼Ÿã‚’å–å¾—ï¼ˆè‡ªåˆ†å«ã‚€ï¼‰
            const siblings = globalData.filter(d => d.relations.father_id === fatherId && !d.relations.is_spouse);

            // 3. è‡ªåˆ†ã¯å±•é–‹ã€å…„å¼Ÿã¯æŠ˜ã‚ŠãŸãŸã‚€
            siblings.forEach(s => {
                if (s.node_code === targetNodeId) {
                    s.collapsed = false;
                } else {
                    s.collapsed = true;
                }
            });
        }

        function formatName(name) {
            return name.replace(/[\/\?<>\\:\*\|":]/g, '_'); // ãƒ•ã‚¡ã‚¤ãƒ«åç¦æ­¢æ–‡å­—é™¤å»
        }

        // æŒ‡å®šã—ãŸãƒãƒ¼ãƒ‰(leafId)ã«åˆ°é”ã™ã‚‹ã¾ã§ã®ãƒ‘ã‚¹ä¸Šã®ãƒãƒ¼ãƒ‰ã¨ã€leafIdä»¥ä¸‹ã®å…¨ãƒãƒ¼ãƒ‰ã‚’å±•é–‹ã™ã‚‹ã€‚
        // ãƒ‘ã‚¹ä¸Šã®ãƒãƒ¼ãƒ‰ã®ã€Œå…„å¼Ÿã€ã§ã‚ã£ã¦ã‚‚ã€ãƒ‘ã‚¹ã«å«ã¾ã‚Œãªã„ã‚‚ã®ã¯æŠ˜ã‚ŠãŸãŸã‚€ã€‚
        function setBranchVisibility(targetId) {
            // å…¨ã¦ã‚’é–‰ã˜ã‚‹ï¼ˆåˆæœŸåŒ–ã™ã‚‹ã‚ˆã‚Šã€ç¾çŠ¶ã‹ã‚‰è¨ˆç®—ã—ãŸã»ã†ãŒé€Ÿã„ãŒã€ç¢ºå®Ÿæ€§é‡è¦–ï¼‰
            // ãŸã ã—ãƒ«ãƒ¼ãƒˆã‚ˆã‚Šä¸Šã¯è§¦ã‚‰ãªã„

            // 1. Ancestor Path ã‚’ç‰¹å®š
            const path = new Set();
            let curr = globalData.find(d => d.node_code === targetId);
            while (curr) {
                path.add(curr.node_code);
                // é…å¶è€…ãƒªãƒ³ã‚¯ã‚‚è€ƒæ…®ã™ã¹ãã ãŒã€ã‚·ãƒ³ãƒ—ãƒ«ã«çˆ¶ç³»/æ¯ç³»ã‚’è¾¿ã‚‹
                if (curr.relations.father_id) {
                    curr = globalData.find(d => d.node_code === curr.relations.father_id);
                } else if (curr.relations.mother_id) {
                    curr = globalData.find(d => d.node_code === curr.relations.mother_id);
                } else {
                    curr = null;
                }
            }

            // 2. å…¨ãƒãƒ¼ãƒ‰ã«å¯¾ã—ã¦å‡¦ç†
            globalData.forEach(d => {
                // targetId ã®å­å­«ã§ã‚ã‚Œã°å±•é–‹ã™ã‚‹
                if (isDescendant(targetId, d.node_code) || d.node_code === targetId) {
                    d.collapsed = false;
                }
                // targetId ã®å…ˆç¥–(path)ã§ã‚ã‚Œã°å±•é–‹ã™ã‚‹
                else if (path.has(d.node_code)) {
                    d.collapsed = false;
                }
                // ãã‚Œä»¥å¤–ï¼ˆå…„å¼Ÿã‚„ãã®å­å­«ãªã©ï¼‰ã¯é–‰ã˜ã‚‹
                // ãŸã ã—ã€ãƒ«ãƒ¼ãƒˆã‚ˆã‚Šä¸Šã®ä¸–ä»£ã‚„ç„¡é–¢ä¿‚ãªãƒãƒ¼ãƒ‰ã‚’ä¸ç”¨æ„ã«é–‰ã˜ã‚‹ã¨å¤‰ã«ãªã‚‹ã®ã§
                // ã€Œpathä¸Šã®ãƒãƒ¼ãƒ‰ã®å­ä¾›ã€ã‹ã¤ã€Œpathã«å«ã¾ã‚Œãªã„ã‚‚ã®ã€ã‚’é–‰ã˜ã‚‹ã®ãŒæ­£è§£
                else {
                    // è¦ªãŒpathã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
                    const father = d.relations.father_id && path.has(d.relations.father_id);
                    const mother = d.relations.mother_id && path.has(d.relations.mother_id);

                    if (father || mother) {
                        d.collapsed = true;
                    }
                }
            });
        }
        function exportToExcel() {
            const rows = globalData.map(d => {
                const r = d.relations;
                const disp = d.display;
                return {
                    "ID": d.node_code,
                    "ä¸–ä»£": d.generation,
                    "å§“å": disp.name,
                    "æ€§åˆ¥": disp.sex === 'male' ? "ç”·" : "å¥³",
                    "çˆ¶ID": r.father_id,
                    "æ¯ID": r.mother_id,
                    "é—œä¿‚": r.relation_type === 'adopted' ? "é¤Šå­" : "è¦ªç”Ÿ",
                    "é †åº": r.birth_order,
                    "é…å¶": r.is_spouse,
                    "é…å¶ID": r.spouse_linked_to,
                    "å©šå§»é †": r.marriage_order,
                    "ç”Ÿå¹´": disp.birth_year,
                    "ç”Ÿ_æ™‚ä»£": disp.birth_era_type,
                    "ç”Ÿ_å¹´è™Ÿ": disp.birth_era_name,
                    "ç”Ÿ_å¹´": disp.birth_era_year,
                    "ç”Ÿ_æœˆ": disp.birth_month,
                    "ç”Ÿ_æ—¥": disp.birth_day,
                    "å’å¹´": disp.death_year,
                    "å’_æ™‚ä»£": disp.death_era_type,
                    "å’_å¹´è™Ÿ": disp.death_era_name,
                    "å’_å¹´": disp.death_era_year,
                    "å’_æœˆ": disp.death_month,
                    "å’_æ—¥": disp.death_day,
                    "å­—": disp.zi,
                    "è™Ÿ": disp.hao,
                    "å‚™è¨»1": disp.memo1,
                    "æ”¶åˆ": d.collapsed
                };
            });
            const ws = XLSX.utils.json_to_sheet(rows);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "å®¶ç³»å›³");
            XLSX.writeFile(wb, "taiwan_family_tree.xlsx");
        }
        document.getElementById('upload-input').addEventListener('change', handleFileSelect, false);
        function handleFileSelect(evt) { const file = evt.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = function (e) { const data = new Uint8Array(e.target.result); const workbook = XLSX.read(data, { type: 'array' }); const rawData = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]); globalData = processExcelData(rawData); initHistory(); renderTree(); evt.target.value = ''; centerOnRoot(); }; reader.readAsArrayBuffer(file); }

        // â˜…å§‹ç¥–ã‚’ä¸­å¿ƒã«è¡¨ç¤º
        function centerOnRoot() {
            let rootCode = currentRootId;
            if (!rootCode) {
                const root = globalData.find(d => !d.relations.father_id && !d.relations.is_spouse && !d.node_code.endsWith('_fa') && !d.node_code.endsWith('_mo'));
                if (root) rootCode = root.node_code;
            }
            if (!rootCode) return;

            // DOMæç”»å¾…ã¡
            setTimeout(() => {
                const el = document.getElementById(`node-${rootCode}`);
                if (!el) return;

                const rect = el.getBoundingClientRect();
                const viewW = window.innerWidth;
                const viewH = window.innerHeight;

                const currentCx = rect.left + rect.width / 2;
                const currentCy = rect.top + rect.height / 2;

                const targetCx = viewW / 2;
                const targetCy = viewH / 2;

                const dx = targetCx - currentCx;
                const dy = targetCy - currentCy;

                panState.x += dx;
                panState.y += dy;

                updateTransform();
            }, 50);
        }

        function processExcelData(rawData) {
            return rawData.map(row => {
                const sexMap = { "ç”·": "male", "å¥³": "female", "male": "male", "female": "female" };
                const relMap = { "é¤Šå­": "adopted" };
                let isSpouse = !!row["é…å¶"];
                if (row["é…å¶"] === "FALSE") isSpouse = false;
                return {
                    node_code: String(row["ID"] || "temp-" + Date.now()),
                    generation: parseInt(row["ä¸–ä»£"]) || 0,
                    collapsed: !!row["æ”¶åˆ"],
                    relations: {
                        father_id: row["çˆ¶ID"] || null,
                        mother_id: row["æ¯ID"] || null,
                        relation_type: relMap[row["é—œä¿‚"]] || "biological",
                        is_spouse: isSpouse,
                        spouse_linked_to: row["é…å¶ID"] || null,
                        marriage_order: parseInt(row["å©šå§»é †"]) || null,
                        birth_order: parseFloat(row["é †åº"]) || 1
                    },
                    display: {
                        name: row["å§“å"] || "åç¨±æœªè¨­å®š",
                        sex: sexMap[row["æ€§åˆ¥"]] || "unknown",
                        birth_year: row["ç”Ÿå¹´"] || null,
                        birth_era_type: row["ç”Ÿ_æ™‚ä»£"] || "",
                        birth_era_name: row["ç”Ÿ_å¹´è™Ÿ"] || "",
                        birth_era_year: row["ç”Ÿ_å¹´"] || "",
                        birth_month: row["ç”Ÿ_æœˆ"] || "",
                        birth_day: row["ç”Ÿ_æ—¥"] || "",
                        death_year: row["å’å¹´"] || null,
                        death_era_type: row["å’_æ™‚ä»£"] || "",
                        death_era_name: row["å’_å¹´è™Ÿ"] || "",
                        death_era_year: row["å’_å¹´"] || "",
                        death_month: row["å’_æœˆ"] || "",
                        death_day: row["å’_æ—¥"] || "",
                        zi: row["å­—"] || null,
                        hao: row["è™Ÿ"] || null,
                        memo1: row["å‚™è¨»1"] || null,
                        memo2: row["å‚™è¨»2"] || null
                    }
                };
            });
        }
        function initSampleData() {
            // Tutorial Data showing multiple features
            const sample = [
                // --- 1st Generation ---
                {
                    ID: "A-1", ä¸–ä»£: 1, å§“å: "å§‹ç¥– (æ“ä½œèªªæ˜)", æ€§åˆ¥: "ç”·",
                    ç”Ÿ_æ™‚ä»£: "japan", ç”Ÿ_å¹´è™Ÿ: "æ–‡ä¹…", ç”Ÿ_å¹´: 1, ç”Ÿå¹´: 1861,
                    å’_æ™‚ä»£: "japan", å’_å¹´è™Ÿ: "æ˜­å’Œ", å’_å¹´: 10, å’å¹´: 1935,
                    é †åº: 1,
                    å‚™è¨»1: "é»æ“Šå¡ç‰‡é€²è¡Œç·¨è¼¯",
                    å‚™è¨»2: `ã€IDè¦å‰‡ã€‘
è‡ªå‹•ç”Ÿæˆï¼Œä½†ä¹Ÿå¯ä»¥å¾ Excel æ•¸æ“šæ‰‹å‹•æ›´æ”¹ã€‚
åŸºæœ¬: é †åº-ä¸–ä»£ (ä¾‹: A-1)
é…å¶: =é †åº (ä¾‹: A-1=1)
å…„å¼Ÿ: ABCâ€¦ (ä¾‹: AB-2)
ç”·å¥³: aBc (å°å¯«:å¥³ã€å¤§å¯«:ç”·)
ç¾©çˆ¶æ¯: _fa, _mo (ä¾‹: A-1=1_fa)

ã€æ“ä½œæ–¹æ³•ã€‘
ãƒ»é»æ“Š: é–‹å•Ÿç·¨è¼¯ç•«é¢
ãƒ»Shift+é»æ“Š: å¤šé¸
ãƒ»æ‹–æ›³: ç§»å‹•ç¯€é»(è¦ªå­/é…å¶è®Šæ›´)
ãƒ»Ctrl+æ»¾è¼ª: ç¸®æ”¾
ãƒ»èƒŒæ™¯æ‹–æ›³: ç§»å‹•ç•«é¢
ãƒ»+æŒ‰éˆ•: æ–°å¢çˆ¶æ¯/å­å¥³/é…å¶

æ­¤æ•¸æ“šå¯é€éã€Œé‡æ–°ç¹ªè£½ã€æˆ–é‡æ–°æ•´ç†é é¢ä¾†å¾©åŸã€‚`
                },
                { ID: "A-1=1", ä¸–ä»£: 1, å§“å: "å¦»", æ€§åˆ¥: "å¥³", é…å¶: true, é…å¶ID: "A-1", å©šå§»é †: 1 },

                // --- 2nd Generation ---
                {
                    ID: "AA-2", ä¸–ä»£: 2, å§“å: "é•·å­ (å¤ªéƒ)", æ€§åˆ¥: "ç”·", çˆ¶ID: "A-1", é †åº: 1,
                    ç”Ÿ_æ™‚ä»£: "japan", ç”Ÿ_å¹´è™Ÿ: "æ˜æ²»", ç”Ÿ_å¹´: 20, ç”Ÿå¹´: 1887,
                    å‚™è¨»1: "æœ‰é…å¶å’Œå­å¥³"
                },
                { ID: "AA-2=1", ä¸–ä»£: 2, å§“å: "é•·å­ä¹‹å¦»", æ€§åˆ¥: "å¥³", é…å¶: true, é…å¶ID: "AA-2", å©šå§»é †: 1 },

                {
                    ID: "Ab-2", ä¸–ä»£: 2, å§“å: "é•·å¥³ (èŠ±å­)", æ€§åˆ¥: "å¥³", çˆ¶ID: "A-1", é †åº: 2,
                    ç”Ÿ_æ™‚ä»£: "japan", ç”Ÿ_å¹´è™Ÿ: "æ˜æ²»", ç”Ÿ_å¹´: 25, ç”Ÿå¹´: 1892
                },
                {
                    ID: "Ab-2=1", ä¸–ä»£: 2, å§“å: "é•·å¥³ä¹‹å¤«", æ€§åˆ¥: "ç”·", é…å¶: true, é…å¶ID: "Ab-2", å©šå§»é †: 1,
                    çˆ¶ID: "Ab-2=1_fa", æ¯ID: "Ab-2=1_mo" // Linked to in-laws
                },

                // In-laws (Parents of Daughter's Husband)
                { ID: "Ab-2=1_fa", ä¸–ä»£: 1, å§“å: "ç¾©çˆ¶", æ€§åˆ¥: "ç”·", å’å¹´: 1900 },
                { ID: "Ab-2=1_mo", ä¸–ä»£: 1, å§“å: "ç¾©æ¯", æ€§åˆ¥: "å¥³", å’å¹´: 1910 },

                {
                    ID: "AC-2", ä¸–ä»£: 2, å§“å: "æ¬¡å­ (æ¬¡éƒ)", æ€§åˆ¥: "ç”·", çˆ¶ID: "A-1", é †åº: 3,
                    ç”Ÿ_æ™‚ä»£: "japan", ç”Ÿ_å¹´è™Ÿ: "æ˜æ²»", ç”Ÿ_å¹´: 30, ç”Ÿå¹´: 1897
                },

                // --- 3rd Generation (Children of Eldest Son) ---
                {
                    ID: "AAA-3", ä¸–ä»£: 3, å§“å: "å­«å­", æ€§åˆ¥: "ç”·", çˆ¶ID: "AA-2", é †åº: 1,
                    ç”Ÿ_æ™‚ä»£: "japan", ç”Ÿ_å¹´è™Ÿ: "å¤§æ­£", ç”Ÿ_å¹´: 5, ç”Ÿå¹´: 1916
                },
                {
                    ID: "AAb-3", ä¸–ä»£: 3, å§“å: "å­«å¥³ (é¤Šå¥³)", æ€§åˆ¥: "å¥³", çˆ¶ID: "AA-2", é †åº: 2,
                    é—œä¿‚: "é¤Šå­", // Special mapping for 'Adopted'
                    ç”Ÿ_æ™‚ä»£: "japan", ç”Ÿ_å¹´è™Ÿ: "å¤§æ­£", ç”Ÿ_å¹´: 8, ç”Ÿå¹´: 1919
                }
            ];
            globalData = processExcelData(sample);
            initHistory();
            renderTree();
            centerOnRoot();
        }

        function showNotification(msg) {
            const el = document.getElementById('notification');
            el.innerText = msg;
            el.style.display = 'block';
            setTimeout(() => { el.style.display = 'none'; }, 2000);
        }

        initSampleData();
    </script>
</body>

</html>